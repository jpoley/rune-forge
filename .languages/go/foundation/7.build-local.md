# Go Local Build Toolchain

## Go Toolchain Overview

Go comes with a comprehensive built-in toolchain that handles building, testing, formatting, and dependency management. The main entry point is the `go` command.

## Core Build Commands

### Basic Build Operations

#### go build
```bash
# Build current package
go build

# Build specific package
go build ./cmd/myapp

# Build with output name
go build -o myapp ./cmd/myapp

# Build for different platforms
GOOS=linux GOARCH=amd64 go build -o myapp-linux ./cmd/myapp
GOOS=windows GOARCH=amd64 go build -o myapp.exe ./cmd/myapp
GOOS=darwin GOARCH=amd64 go build -o myapp-darwin ./cmd/myapp

# Build with ldflags (linker flags)
go build -ldflags="-X main.version=1.0.0 -X main.buildDate=$(date -u +%Y%m%d-%H%M%S)" ./cmd/myapp

# Build all packages in module
go build ./...
```

#### go install
```bash
# Install to $GOPATH/bin or $GOBIN
go install ./cmd/myapp

# Install specific version of tool
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# Install from current directory
go install .
```

#### go run
```bash
# Run Go program directly
go run main.go

# Run package
go run ./cmd/myapp

# Run with arguments
go run ./cmd/myapp -flag value arg1 arg2

# Run with build flags
go run -ldflags="-X main.debug=true" ./cmd/myapp
```

### Advanced Build Options

#### Build Flags
```bash
# Verbose build output
go build -v ./...

# Show packages being built
go build -x ./...

# Build without caching
go build -a ./...

# Specify number of programs to run simultaneously
go build -p 4 ./...

# Enable race detection
go build -race ./...

# Build with custom tags
go build -tags "integration,debug" ./...

# Optimize for size
go build -ldflags="-s -w" ./...
```

#### Custom Build Constraints
```go
// File: config_dev.go
// +build dev

package main

const debugMode = true

// File: config_prod.go  
// +build !dev

package main

const debugMode = false
```

```bash
# Build with dev tag
go build -tags dev

# Build without dev tag (production)
go build
```

## Dependency Management

### Go Modules (go mod)

#### Module Initialization
```bash
# Initialize new module
go mod init github.com/username/projectname

# Initialize with custom module path
go mod init example.com/myproject
```

#### Dependency Operations
```bash
# Add dependency
go get github.com/gin-gonic/gin

# Add specific version
go get github.com/gin-gonic/gin@v1.8.1

# Add development dependency
go get -d github.com/stretchr/testify

# Update dependencies
go get -u ./...

# Update specific dependency
go get -u github.com/gin-gonic/gin

# Remove unused dependencies
go mod tidy

# Download dependencies
go mod download

# Verify dependencies
go mod verify
```

#### Module Information
```bash
# Show module requirements
go list -m all

# Show available versions
go list -m -versions github.com/gin-gonic/gin

# Show module graph
go mod graph

# Show why dependency is needed
go mod why github.com/gin-gonic/gin

# Edit go.mod file
go mod edit -require github.com/gin-gonic/gin@v1.8.1
go mod edit -droprequire github.com/old/package
```

### Vendoring
```bash
# Create vendor directory
go mod vendor

# Build using vendor
go build -mod=vendor

# Sync vendor with go.mod
go mod vendor
```

## Testing Framework

### Running Tests

#### Basic Test Commands
```bash
# Run all tests in current package
go test

# Run tests in all packages
go test ./...

# Run tests with verbose output
go test -v

# Run specific test function
go test -run TestMyFunction

# Run tests matching pattern
go test -run "Test.*Integration"

# Run tests in specific package
go test ./internal/service
```

#### Test Coverage
```bash
# Run tests with coverage
go test -cover

# Generate coverage profile
go test -coverprofile=coverage.out

# View coverage in browser
go tool cover -html=coverage.out

# Show coverage by function
go tool cover -func=coverage.out

# Set coverage threshold
go test -cover -coverprofile=coverage.out
go tool cover -func=coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//'
```

#### Benchmark Tests
```bash
# Run benchmarks
go test -bench=.

# Run specific benchmark
go test -bench=BenchmarkMyFunction

# Run benchmarks with memory stats
go test -bench=. -benchmem

# Run benchmarks multiple times
go test -bench=. -count=5

# Set benchmark time
go test -bench=. -benchtime=10s
```

#### Advanced Testing
```bash
# Race detection in tests
go test -race

# Enable CPU profiling
go test -cpuprofile=cpu.prof

# Enable memory profiling
go test -memprofile=mem.prof

# Run tests in parallel
go test -parallel 4

# Disable test caching
go test -count=1

# Short tests only
go test -short

# Run tests with timeout
go test -timeout 30s
```

## Code Quality Tools

### Built-in Tools

#### go fmt
```bash
# Format current package
go fmt

# Format all packages
go fmt ./...

# Check if formatting is needed (don't modify)
gofmt -d .

# Format with custom settings
gofmt -w -s .  # -s: simplify code
```

#### go vet
```bash
# Run vet on current package
go vet

# Run vet on all packages
go vet ./...

# Run specific vet checks
go vet -tags=integration ./...
```

#### go doc
```bash
# Show documentation for package
go doc fmt

# Show documentation for function
go doc fmt.Printf

# Show documentation for current package
go doc

# Start documentation server
go doc -http=:6060
```

### External Code Quality Tools

#### golangci-lint (Comprehensive Linter)
```bash
# Install
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# Run all enabled linters
golangci-lint run

# Run specific linters
golangci-lint run --enable=gosec,goconst

# Configuration file: .golangci.yml
```

```yaml
# .golangci.yml
run:
  timeout: 5m
  go: "1.20"

linters-settings:
  gocyclo:
    min-complexity: 15
  dupl:
    threshold: 100
  goconst:
    min-len: 2
    min-occurrences: 2

linters:
  enable:
    - errcheck
    - gosimple
    - govet
    - ineffassign
    - staticcheck
    - typecheck
    - unused
    - gosec
    - gocyclo
    - dupl
    - goconst

issues:
  exclude-use-default: false
  max-issues-per-linter: 0
  max-same-issues: 0
```

#### staticcheck
```bash
# Install
go install honnef.co/go/tools/cmd/staticcheck@latest

# Run staticcheck
staticcheck ./...
```

#### gosec (Security Analysis)
```bash
# Install
go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest

# Run security analysis
gosec ./...

# Generate report
gosec -fmt json -out results.json ./...
```

## Build Automation

### Makefiles for Go Projects

#### Basic Makefile
```makefile
# Makefile
.PHONY: build test clean install lint fmt vet

# Variables
BINARY_NAME=myapp
VERSION?=dev
BUILD_TIME=$(shell date -u +%Y%m%d-%H%M%S)
LDFLAGS=-ldflags="-X main.version=${VERSION} -X main.buildTime=${BUILD_TIME}"

# Build targets
build:
	go build ${LDFLAGS} -o bin/${BINARY_NAME} ./cmd/myapp

build-all:
	GOOS=linux GOARCH=amd64 go build ${LDFLAGS} -o bin/${BINARY_NAME}-linux ./cmd/myapp
	GOOS=darwin GOARCH=amd64 go build ${LDFLAGS} -o bin/${BINARY_NAME}-darwin ./cmd/myapp
	GOOS=windows GOARCH=amd64 go build ${LDFLAGS} -o bin/${BINARY_NAME}.exe ./cmd/myapp

install:
	go install ${LDFLAGS} ./cmd/myapp

# Testing
test:
	go test -v ./...

test-coverage:
	go test -v -cover -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html

test-race:
	go test -race ./...

bench:
	go test -bench=. -benchmem ./...

# Code quality
lint:
	golangci-lint run

fmt:
	go fmt ./...

vet:
	go vet ./...

# Dependencies
deps:
	go mod download
	go mod tidy

deps-update:
	go get -u ./...
	go mod tidy

# Cleaning
clean:
	go clean
	rm -rf bin/
	rm -f coverage.out coverage.html

# Development
dev: fmt vet lint test build

# Release
release: clean deps test lint build-all
```

#### Advanced Makefile with Docker
```makefile
# Advanced Makefile
DOCKER_IMAGE=myapp
DOCKER_TAG?=latest
DOCKER_REGISTRY?=your-registry.com

# Docker targets
docker-build:
	docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .

docker-run:
	docker run -p 8080:8080 ${DOCKER_IMAGE}:${DOCKER_TAG}

docker-push:
	docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}
	docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE}:${DOCKER_TAG}

# Multi-stage Docker build
docker-build-multi:
	docker build -f Dockerfile.multi -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
```

### Task Runners

#### Using Task (Taskfile.yml)
```yaml
# Taskfile.yml
version: '3'

vars:
  BINARY_NAME: myapp
  VERSION: 
    sh: git describe --tags --always --dirty
  BUILD_TIME:
    sh: date -u +%Y%m%d-%H%M%S

tasks:
  build:
    desc: Build the application
    cmds:
      - go build -ldflags="-X main.version={{.VERSION}} -X main.buildTime={{.BUILD_TIME}}" -o bin/{{.BINARY_NAME}} ./cmd/myapp

  test:
    desc: Run tests
    cmds:
      - go test -v ./...

  test:coverage:
    desc: Run tests with coverage
    cmds:
      - go test -v -cover -coverprofile=coverage.out ./...
      - go tool cover -html=coverage.out -o coverage.html

  lint:
    desc: Run linters
    cmds:
      - golangci-lint run

  fmt:
    desc: Format code
    cmds:
      - go fmt ./...

  dev:
    desc: Development workflow
    deps: [fmt, lint, test, build]

  clean:
    desc: Clean build artifacts
    cmds:
      - rm -rf bin/
      - rm -f coverage.out coverage.html
```

## Performance Profiling

### CPU Profiling
```bash
# Profile during test
go test -cpuprofile=cpu.prof -bench=.

# Profile running application
go tool pprof http://localhost:6060/debug/pprof/profile

# Analyze profile
go tool pprof cpu.prof
```

### Memory Profiling
```bash
# Memory profile during test
go test -memprofile=mem.prof -bench=.

# Heap profile from running app
go tool pprof http://localhost:6060/debug/pprof/heap

# Analyze memory profile
go tool pprof mem.prof
```

### Adding Profiling to Application
```go
// main.go
package main

import (
    _ "net/http/pprof"
    "net/http"
    "log"
)

func main() {
    // Enable pprof endpoint
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // Your application code
}
```

## Build Optimization

### Compiler Optimizations
```bash
# Optimize for size
go build -ldflags="-s -w" ./...

# Disable inlining
go build -gcflags="-N" ./...

# Disable optimizations (for debugging)
go build -gcflags="-N -l" ./...

# Enable all escape analysis
go build -gcflags="-m" ./...
```

### Link Time Optimization
```bash
# Strip symbol table and debug info
go build -ldflags="-s -w"

# Set package variables at build time
go build -ldflags="-X main.version=1.0.0 -X main.commit=$(git rev-parse HEAD)"
```

### Build Caching
```bash
# Show build cache location
go env GOCACHE

# Clear build cache
go clean -cache

# Clear module cache
go clean -modcache

# Disable build cache
GOCACHE=off go build
```

## Cross-Platform Building

### Supported Platforms
```bash
# List all supported platforms
go tool dist list

# Common cross-compilation targets
GOOS=linux GOARCH=amd64 go build
GOOS=linux GOARCH=arm64 go build
GOOS=windows GOARCH=amd64 go build
GOOS=darwin GOARCH=amd64 go build
GOOS=darwin GOARCH=arm64 go build
```

### Build Script for Multiple Platforms
```bash
#!/bin/bash
# build_all.sh

BINARY_NAME="myapp"
VERSION=${1:-"dev"}
PLATFORMS=("linux/amd64" "linux/arm64" "darwin/amd64" "darwin/arm64" "windows/amd64")

for platform in "${PLATFORMS[@]}"
do
    platform_split=(${platform//\// })
    GOOS=${platform_split[0]}
    GOARCH=${platform_split[1]}
    
    output_name=$BINARY_NAME'-'$VERSION'-'$GOOS'-'$GOARCH
    if [ $GOOS = "windows" ]; then
        output_name+='.exe'
    fi
    
    env GOOS=$GOOS GOARCH=$GOARCH go build -o bin/$output_name ./cmd/myapp
    if [ $? -ne 0 ]; then
        echo 'An error has occurred! Aborting the script execution...'
        exit 1
    fi
done
```

## Development Workflow

### Hot Reload Development
```bash
# Install air (hot reload tool)
go install github.com/cosmtrek/air@latest

# Create .air.toml configuration
air init

# Run with hot reload
air
```

```toml
# .air.toml
root = "."
testdata_dir = "testdata"
tmp_dir = "tmp"

[build]
args_bin = []
bin = "./tmp/main"
cmd = "go build -o ./tmp/main ./cmd/myapp"
delay = 1000
exclude_dir = ["assets", "tmp", "vendor", "testdata"]
exclude_file = []
exclude_regex = ["_test.go"]
exclude_unchanged = false
follow_symlink = false
full_bin = ""
include_dir = []
include_ext = ["go", "tpl", "tmpl", "html"]
include_file = []
kill_delay = "0s"
log = "build-errors.log"
send_interrupt = false
stop_on_root = false

[color]
app = ""
build = "yellow"
main = "magenta"
runner = "green"
watcher = "cyan"

[log]
time = false

[misc]
clean_on_exit = false
```

### IDE Integration

#### VS Code Configuration
```json
// .vscode/settings.json
{
    "go.useLanguageServer": true,
    "go.formatTool": "goimports",
    "go.lintTool": "golangci-lint",
    "go.buildOnSave": "package",
    "go.vetOnSave": "package",
    "go.coverOnSave": true,
    "go.testFlags": ["-v"],
    "go.testTimeout": "30s"
}
```

```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Launch Package",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/myapp"
        },
        {
            "name": "Debug test",
            "type": "go",
            "request": "launch",
            "mode": "test",
            "program": "${workspaceFolder}"
        }
    ]
}
```

## Complete Build Automation Example

### Project Structure
```
myproject/
├── .golangci.yml
├── .air.toml
├── Makefile
├── Taskfile.yml
├── go.mod
├── go.sum
├── cmd/
│   └── myapp/
│       └── main.go
├── internal/
│   ├── config/
│   ├── handler/
│   └── service/
├── pkg/
│   └── utils/
├── scripts/
│   ├── build.sh
│   └── test.sh
└── docs/
```

### Complete Build Script
```bash
#!/bin/bash
# scripts/build.sh

set -e

echo "Starting build process..."

# Check dependencies
echo "Checking dependencies..."
go mod download
go mod verify

# Format code
echo "Formatting code..."
go fmt ./...

# Vet code
echo "Vetting code..."
go vet ./...

# Run linters
echo "Running linters..."
golangci-lint run

# Run tests
echo "Running tests..."
go test -race -cover ./...

# Build application
echo "Building application..."
VERSION=${VERSION:-"dev"}
BUILD_TIME=$(date -u +%Y%m%d-%H%M%S)
COMMIT=$(git rev-parse --short HEAD)

go build \
    -ldflags="-X main.version=${VERSION} -X main.buildTime=${BUILD_TIME} -X main.commit=${COMMIT}" \
    -o bin/myapp \
    ./cmd/myapp

echo "Build completed successfully!"
echo "Binary: bin/myapp"
echo "Version: ${VERSION}"
echo "Build time: ${BUILD_TIME}"
echo "Commit: ${COMMIT}"
```

This comprehensive local build toolchain provides everything needed for Go development, from basic building to advanced optimization and cross-platform deployment.

## References
- [Go Command Documentation](https://pkg.go.dev/cmd/go)
- [Go Modules](https://go.dev/blog/using-go-modules)
- [Go Build Constraints](https://pkg.go.dev/go/build#hdr-Build_Constraints)
- [golangci-lint](https://golangci-lint.run/)
- [Task Runner](https://taskfile.dev/)