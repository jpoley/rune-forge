# Go Types and Collections

## Type System Overview

Go has a static type system with:
- **Basic types**: Built-in primitive types
- **Composite types**: Arrays, slices, maps, channels, structs
- **Interface types**: Define method sets
- **Function types**: Functions are first-class citizens
- **Pointer types**: Memory address references

## Basic Types

### Numeric Types

#### Integers
```go
// Signed integers
int8    // -128 to 127
int16   // -32,768 to 32,767
int32   // -2^31 to 2^31-1 (alias: rune)
int64   // -2^63 to 2^63-1
int     // Platform dependent (32 or 64 bit)

// Unsigned integers
uint8   // 0 to 255 (alias: byte)
uint16  // 0 to 65,535
uint32  // 0 to 2^32-1
uint64  // 0 to 2^64-1
uint    // Platform dependent (32 or 64 bit)
uintptr // Pointer-sized integer

// Examples
var age int8 = 25
var count uint32 = 1000000
var id int = 42
```

#### Floating Point
```go
float32  // IEEE-754 32-bit floating point
float64  // IEEE-754 64-bit floating point

var price float64 = 99.99
var ratio float32 = 0.5
```

#### Complex Numbers
```go
complex64   // Complex number with float32 components
complex128  // Complex number with float64 components

var c1 complex64 = 5 + 12i
var c2 complex128 = complex(3.5, 2.8)

// Extract real and imaginary parts
real := real(c1)  // 5
imag := imag(c1)  // 12
```

### Boolean Type
```go
bool  // true or false

var isActive bool = true
var isComplete bool  // Zero value: false
```

### String Type
```go
string  // UTF-8 encoded text

var name string = "Go Programming"
var empty string  // Zero value: ""

// String literals
var multiline = `This is a
multi-line string
using backticks`

// String operations
length := len(name)                    // 14
first := name[0]                       // 'G' (byte)
substring := name[3:7]                 // "Prog"
concatenated := "Hello " + "World"     // "Hello World"
```

### Type Aliases and Definitions

#### Type Alias (Go 1.9+)
```go
type StringAlias = string
type ByteSlice = []byte

var s StringAlias = "hello"  // Same as string
```

#### Type Definition
```go
type MyString string
type UserID int64

var custom MyString = "hello"
var uid UserID = 12345

// Custom types are distinct types
var regular string = "hello"
// regular = custom  // Compile error! Need conversion
regular = string(custom)  // OK with conversion
```

## Arrays

### Array Declaration and Initialization
```go
// Declaration with size
var arr1 [5]int                    // [0 0 0 0 0]

// Declaration with initialization
var arr2 = [5]int{1, 2, 3, 4, 5}  // [1 2 3 4 5]

// Array literal with size inference
arr3 := [...]int{10, 20, 30}      // [10 20 30], size = 3

// Partial initialization
arr4 := [5]int{2: 100, 4: 200}    // [0 0 100 0 200]
```

### Array Properties
```go
arr := [3]string{"Go", "is", "awesome"}

// Arrays have fixed size known at compile time
length := len(arr)           // 3
size := cap(arr)             // 3 (same as length for arrays)

// Arrays are value types (copied on assignment)
arr2 := arr                  // arr2 is a copy of arr
arr2[0] = "Python"           // arr is unchanged

// Comparing arrays
var a1 = [3]int{1, 2, 3}
var a2 = [3]int{1, 2, 3}
equal := a1 == a2            // true
```

### Multi-dimensional Arrays
```go
// 2D array
var matrix [3][4]int

// Initialize 2D array
matrix2 := [2][3]int{
    {1, 2, 3},
    {4, 5, 6},
}

// Access elements
matrix2[0][1] = 10  // Set element at row 0, column 1
value := matrix2[1][2]  // Get element at row 1, column 2
```

## Slices

### Slice Basics
```go
// Slice declaration
var slice1 []int              // nil slice

// Create slice with make
slice2 := make([]int, 5)      // [0 0 0 0 0], length=5, capacity=5
slice3 := make([]int, 3, 10)  // [0 0 0], length=3, capacity=10

// Slice literal
slice4 := []int{1, 2, 3, 4, 5}

// Slice from array
arr := [5]int{10, 20, 30, 40, 50}
slice5 := arr[1:4]            // [20 30 40], shares memory with arr
```

### Slice Operations

#### Length and Capacity
```go
slice := make([]int, 3, 10)
fmt.Printf("len=%d cap=%d\n", len(slice), cap(slice))  // len=3 cap=10
```

#### Appending Elements
```go
var slice []int               // nil slice
slice = append(slice, 1)      // [1]
slice = append(slice, 2, 3)   // [1 2 3]

// Append another slice
other := []int{4, 5, 6}
slice = append(slice, other...)  // [1 2 3 4 5 6]
```

#### Slicing Operations
```go
original := []int{0, 1, 2, 3, 4, 5}

slice1 := original[2:]        // [2 3 4 5] (from index 2 to end)
slice2 := original[:3]        // [0 1 2] (from start to index 3)
slice3 := original[1:4]       // [1 2 3] (from index 1 to 4)
slice4 := original[:]         // [0 1 2 3 4 5] (full slice)

// Three-index slicing (Go 1.2+)
slice5 := original[1:3:4]     // [1 2], cap=3 (high-low)
```

#### Copying Slices
```go
source := []int{1, 2, 3, 4, 5}

// Method 1: Using copy function
dest1 := make([]int, len(source))
copy(dest1, source)

// Method 2: Using append
dest2 := append([]int(nil), source...)

// Method 3: Using slice expression
dest3 := source[:]  // Shares underlying array!
```

### Slice Internals
```go
// Slice structure (conceptual)
type slice struct {
    ptr *ElementType  // Pointer to underlying array
    len int          // Current length
    cap int          // Capacity
}

// Growth pattern when appending
func demonstrateGrowth() {
    var s []int
    for i := 0; i < 20; i++ {
        s = append(s, i)
        fmt.Printf("len=%d cap=%d\n", len(s), cap(s))
    }
    // Growth typically: 1 -> 2 -> 4 -> 8 -> 16 -> 32...
}
```

### Slice Patterns

#### Removing Elements
```go
slice := []int{1, 2, 3, 4, 5}

// Remove element at index 2
index := 2
slice = append(slice[:index], slice[index+1:]...)  // [1 2 4 5]

// Remove last element
slice = slice[:len(slice)-1]

// Remove first element
slice = slice[1:]
```

#### Inserting Elements
```go
slice := []int{1, 2, 4, 5}

// Insert 3 at index 2
index := 2
value := 3
slice = append(slice[:index], append([]int{value}, slice[index:]...)...)
// Result: [1 2 3 4 5]
```

#### Filter Slice
```go
func filter(slice []int, predicate func(int) bool) []int {
    result := slice[:0]  // Reuse backing array
    for _, item := range slice {
        if predicate(item) {
            result = append(result, item)
        }
    }
    return result
}

// Usage
numbers := []int{1, 2, 3, 4, 5, 6}
evens := filter(numbers, func(n int) bool { return n%2 == 0 })  // [2 4 6]
```

## Maps

### Map Declaration and Initialization
```go
// Declaration
var map1 map[string]int        // nil map, cannot write to it

// Initialize with make
map2 := make(map[string]int)   // Empty map, ready to use

// Map literal
map3 := map[string]int{
    "apple":  5,
    "banana": 3,
    "orange": 8,
}

// Initialize with make and capacity hint
map4 := make(map[string]int, 100)  // Hint for performance
```

### Map Operations

#### Basic Operations
```go
m := make(map[string]int)

// Set values
m["key1"] = 100
m["key2"] = 200

// Get values
value1 := m["key1"]         // 100
value2 := m["nonexistent"]  // 0 (zero value)

// Check if key exists
value, ok := m["key1"]
if ok {
    fmt.Printf("key1 = %d\n", value)
}

// Delete key
delete(m, "key1")

// Get map length
size := len(m)
```

#### Iterating Over Maps
```go
m := map[string]int{
    "a": 1, "b": 2, "c": 3,
}

// Iterate over key-value pairs (order not guaranteed)
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}

// Iterate over keys only
for key := range m {
    fmt.Printf("Key: %s\n", key)
}

// Iterate over values only
for _, value := range m {
    fmt.Printf("Value: %d\n", value)
}
```

### Map Key Requirements
```go
// Valid key types (comparable types)
map[string]int           // string keys
map[int]string           // integer keys  
map[[3]int]string        // array keys
map[struct{x, y int}]bool // struct keys (if all fields comparable)

// Invalid key types (not comparable)
// map[[]int]string      // slice keys - compile error
// map[map[string]int]int // map keys - compile error
// map[func()]int        // function keys - compile error
```

### Advanced Map Patterns

#### Map of Slices
```go
groups := make(map[string][]string)

// Add items to groups
groups["fruits"] = append(groups["fruits"], "apple", "banana")
groups["vegetables"] = append(groups["vegetables"], "carrot", "broccoli")
```

#### Nested Maps
```go
userPrefs := make(map[string]map[string]interface{})

// Initialize inner map
userPrefs["user123"] = make(map[string]interface{})
userPrefs["user123"]["theme"] = "dark"
userPrefs["user123"]["language"] = "en"

// Safe access pattern
func getNestedValue(m map[string]map[string]interface{}, user, key string) (interface{}, bool) {
    if innerMap, exists := m[user]; exists {
        if value, exists := innerMap[key]; exists {
            return value, true
        }
    }
    return nil, false
}
```

#### Synchronized Map (concurrent access)
```go
import "sync"

type SafeMap struct {
    mu   sync.RWMutex
    data map[string]interface{}
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]interface{}),
    }
}

func (sm *SafeMap) Set(key string, value interface{}) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.data[key] = value
}

func (sm *SafeMap) Get(key string) (interface{}, bool) {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    value, ok := sm.data[key]
    return value, ok
}
```

## Structs

### Struct Definition and Initialization
```go
// Struct definition
type Person struct {
    Name    string
    Age     int
    Email   string
    private int  // unexported field
}

// Various initialization methods
var p1 Person                           // Zero value initialization
p2 := Person{"John", 30, "john@example.com", 0}  // Positional
p3 := Person{
    Name:  "Jane",
    Email: "jane@example.com",
    Age:   25,
}                                      // Named fields
p4 := Person{Name: "Bob"}              // Partial initialization

// Pointer to struct
p5 := &Person{Name: "Alice", Age: 28}
```

### Struct Methods
```go
type Rectangle struct {
    Width  float64
    Height float64
}

// Value receiver method
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Pointer receiver method
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

// Usage
rect := Rectangle{Width: 10, Height: 5}
area := rect.Area()        // 50.0
rect.Scale(2.0)           // rect is now {20, 10}
```

### Struct Embedding
```go
type Address struct {
    Street   string
    City     string
    PostCode string
}

type Employee struct {
    Name    string
    ID      int
    Address // Embedded struct (anonymous field)
}

// Usage
emp := Employee{
    Name: "John",
    ID:   123,
    Address: Address{
        Street:   "123 Main St",
        City:     "New York",
        PostCode: "10001",
    },
}

// Access embedded fields directly
city := emp.City           // Direct access
street := emp.Address.Street // Explicit access
```

### Struct Tags
```go
import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Email    string `json:"email,omitempty"`
    Password string `json:"-"`              // Ignored
    Created  string `json:"created_at"`
}

// JSON marshaling uses struct tags
user := User{ID: 1, Name: "John", Email: "john@example.com"}
jsonData, _ := json.Marshal(user)
fmt.Printf("%s\n", jsonData)  // {"id":1,"name":"John","email":"john@example.com","created_at":""}
```

## Interfaces

### Interface Declaration
```go
// Interface definition
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}

// Interface composition
type ReadWriter interface {
    Reader
    Writer
}

// Empty interface
type Any interface{}  // or interface{} in older Go versions
```

### Interface Implementation
```go
import "fmt"

type Logger interface {
    Log(message string)
}

// Console logger implementation
type ConsoleLogger struct{}

func (c ConsoleLogger) Log(message string) {
    fmt.Println("Console:", message)
}

// File logger implementation
type FileLogger struct {
    filename string
}

func (f FileLogger) Log(message string) {
    // Write to file...
    fmt.Printf("File[%s]: %s\n", f.filename, message)
}

// Usage (implicit interface satisfaction)
func processWithLogger(logger Logger) {
    logger.Log("Processing started")
}

// Both types automatically implement Logger
processWithLogger(ConsoleLogger{})
processWithLogger(FileLogger{filename: "app.log"})
```

### Type Assertions and Switches

#### Type Assertion
```go
var i interface{} = 42

// Type assertion with panic risk
value := i.(int)  // 42, panics if i is not int

// Safe type assertion
value, ok := i.(int)
if ok {
    fmt.Printf("i is an int: %d\n", value)
}

// Assertion to interface
var w io.Writer = os.Stdout
if file, ok := w.(*os.File); ok {
    fmt.Printf("It's a file: %s\n", file.Name())
}
```

#### Type Switch
```go
func processValue(v interface{}) {
    switch value := v.(type) {
    case string:
        fmt.Printf("String: %s (length: %d)\n", value, len(value))
    case int:
        fmt.Printf("Integer: %d\n", value)
    case []int:
        fmt.Printf("Integer slice: %v (length: %d)\n", value, len(value))
    case nil:
        fmt.Println("nil value")
    default:
        fmt.Printf("Unknown type: %T\n", value)
    }
}
```

### Interface Patterns

#### Strategy Pattern
```go
type SortStrategy interface {
    Sort([]int)
}

type BubbleSort struct{}
func (BubbleSort) Sort(data []int) { /* bubble sort implementation */ }

type QuickSort struct{}
func (QuickSort) Sort(data []int) { /* quick sort implementation */ }

type Sorter struct {
    strategy SortStrategy
}

func (s *Sorter) SetStrategy(strategy SortStrategy) {
    s.strategy = strategy
}

func (s *Sorter) Sort(data []int) {
    s.strategy.Sort(data)
}
```

#### Interface Segregation
```go
// Large interface (not ideal)
type LargeInterface interface {
    Read() error
    Write() error
    Connect() error
    Close() error
    Validate() error
}

// Better: Smaller, focused interfaces
type Reader interface {
    Read() error
}

type Writer interface {
    Write() error
}

type Connector interface {
    Connect() error
    Close() error
}

type Validator interface {
    Validate() error
}
```

## Pointers

### Pointer Basics
```go
var x int = 42
var p *int = &x    // p points to x

fmt.Printf("x = %d\n", x)      // 42
fmt.Printf("&x = %p\n", &x)    // Memory address
fmt.Printf("p = %p\n", p)      // Same memory address
fmt.Printf("*p = %d\n", *p)    // 42 (dereferencing)

*p = 100               // Modify x through pointer
fmt.Printf("x = %d\n", x)      // 100
```

### Pointers vs Values

#### Value Semantics
```go
type Point struct {
    X, Y int
}

func movePoint(p Point, dx, dy int) Point {
    p.X += dx
    p.Y += dy
    return p  // Return modified copy
}

// Usage
original := Point{X: 1, Y: 2}
moved := movePoint(original, 10, 20)
// original is unchanged: {1, 2}
// moved is: {11, 22}
```

#### Pointer Semantics
```go
func movePointPtr(p *Point, dx, dy int) {
    p.X += dx  // Modifies original
    p.Y += dy
}

// Usage
point := Point{X: 1, Y: 2}
movePointPtr(&point, 10, 20)
// point is now: {11, 22}
```

### Pointer Best Practices
```go
// Good: Check for nil before dereferencing
func safeDereference(p *int) {
    if p != nil {
        fmt.Printf("Value: %d\n", *p)
    } else {
        fmt.Println("Nil pointer")
    }
}

// Good: Return pointers for large structs
func createLargeStruct() *LargeStruct {
    return &LargeStruct{
        // ... lots of fields
    }
}

// Good: Use pointers for methods that modify receiver
func (s *SomeStruct) Modify() {
    s.field = "modified"
}
```

## Type Conversions

### Basic Type Conversions
```go
var i int = 42
var f float64 = float64(i)    // int to float64
var s string = fmt.Sprintf("%d", i)  // int to string

var str string = "123"
num, err := strconv.Atoi(str)  // string to int (with error checking)
if err == nil {
    fmt.Printf("Number: %d\n", num)
}
```

### String Conversions
```go
import "strconv"

// String to numeric
i, err := strconv.Atoi("123")           // string to int
f, err := strconv.ParseFloat("3.14", 64) // string to float64
b, err := strconv.ParseBool("true")     // string to bool

// Numeric to string
str1 := strconv.Itoa(123)               // int to string
str2 := strconv.FormatFloat(3.14, 'f', 2, 64)  // float64 to string
str3 := strconv.FormatBool(true)        // bool to string
```

### Custom Type Conversions
```go
type Celsius float64
type Fahrenheit float64

func (c Celsius) ToFahrenheit() Fahrenheit {
    return Fahrenheit(c*9/5 + 32)
}

func (f Fahrenheit) ToCelsius() Celsius {
    return Celsius((f - 32) * 5 / 9)
}

// Usage
temp := Celsius(25)
fahrenheit := temp.ToFahrenheit()  // 77Â°F
```

## Zero Values

### Zero Values by Type
```go
var b bool        // false
var i int         // 0
var f float64     // 0.0
var s string      // ""
var p *int        // nil
var slice []int   // nil
var m map[string]int  // nil
var ch chan int   // nil
var fn func()     // nil

// Struct zero value: all fields are their zero values
type Person struct {
    Name string
    Age  int
}
var person Person  // {Name: "", Age: 0}
```

### Zero Value Patterns
```go
// Useful zero values
var buffer bytes.Buffer  // Ready to use
var wg sync.WaitGroup   // Ready to use

// Zero values that need initialization
var slice []int         // Need make() or literal to use
var m map[string]int    // Need make() or literal to write

// Safe zero value check
func isZero(s []int) bool {
    return len(s) == 0  // Works for both nil and empty slice
}
```

## Performance Considerations

### Memory Layout Optimization
```go
// Bad: Poor memory layout (24 bytes on 64-bit)
type BadStruct struct {
    flag1 bool     // 1 byte + 7 padding
    count int64    // 8 bytes
    flag2 bool     // 1 byte + 7 padding
}

// Good: Optimized layout (10 bytes on 64-bit)
type GoodStruct struct {
    count int64    // 8 bytes
    flag1 bool     // 1 byte
    flag2 bool     // 1 byte
}
```

### Slice vs Array Performance
```go
// Array: stack allocated, copied by value
func processArray(arr [1000000]int) {
    // arr is a copy - expensive!
}

// Slice: reference to underlying array
func processSlice(slice []int) {
    // slice header is copied (24 bytes) - cheap!
}
```

### Map Performance Tips
```go
// Pre-size maps when possible
m := make(map[string]int, 1000)  // Reduces rehashing

// Use struct{} for sets (zero memory value type)
set := make(map[string]struct{})
set["key"] = struct{}{}
if _, exists := set["key"]; exists {
    // key exists in set
}
```

## Common Patterns and Idioms

### Optional Values with Pointers
```go
type User struct {
    Name     string
    Email    *string  // Optional field
    Age      *int     // Optional field
}

func NewUser(name string) *User {
    return &User{Name: name}
}

func (u *User) SetEmail(email string) {
    u.Email = &email
}

func (u *User) GetEmail() string {
    if u.Email != nil {
        return *u.Email
    }
    return ""
}
```

### Builder Pattern
```go
type QueryBuilder struct {
    table   string
    fields  []string
    where   []string
    orderBy []string
}

func NewQueryBuilder() *QueryBuilder {
    return &QueryBuilder{}
}

func (qb *QueryBuilder) Table(table string) *QueryBuilder {
    qb.table = table
    return qb
}

func (qb *QueryBuilder) Select(fields ...string) *QueryBuilder {
    qb.fields = append(qb.fields, fields...)
    return qb
}

func (qb *QueryBuilder) Where(condition string) *QueryBuilder {
    qb.where = append(qb.where, condition)
    return qb
}

func (qb *QueryBuilder) OrderBy(field string) *QueryBuilder {
    qb.orderBy = append(qb.orderBy, field)
    return qb
}

func (qb *QueryBuilder) Build() string {
    // Build SQL query string
    query := "SELECT " + strings.Join(qb.fields, ", ")
    query += " FROM " + qb.table
    if len(qb.where) > 0 {
        query += " WHERE " + strings.Join(qb.where, " AND ")
    }
    if len(qb.orderBy) > 0 {
        query += " ORDER BY " + strings.Join(qb.orderBy, ", ")
    }
    return query
}

// Usage
query := NewQueryBuilder().
    Table("users").
    Select("name", "email").
    Where("age > 18").
    Where("active = true").
    OrderBy("name").
    Build()
```

## References
- [Go Type System](https://go.dev/ref/spec#Types)
- [Slices: usage and internals](https://go.dev/blog/slices-intro)
- [Go Maps in Action](https://go.dev/blog/maps)
- [Laws of Reflection](https://go.dev/blog/laws-of-reflection)
- [Interface Values](https://research.swtch.com/interfaces)