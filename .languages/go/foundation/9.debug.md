# Go Debugging Guide

## Overview

Go provides excellent debugging capabilities through various tools and techniques. This comprehensive guide covers debugging strategies from basic print statements to advanced profiling and step-through debugging.

## Built-in Debugging Tools

### Print-based Debugging

#### Basic Print Statements
```go
import "fmt"

func debugExample() {
    value := 42
    fmt.Printf("Debug: value = %d\n", value)
    fmt.Printf("Debug: value type = %T\n", value)
    
    // More detailed formatting
    fmt.Printf("Debug: %#v\n", someStruct)  // Go-syntax representation
    fmt.Printf("Debug: %+v\n", someStruct)  // Include field names
}
```

#### log Package for Debugging
```go
import (
    "log"
    "os"
)

func init() {
    // Configure logging for debugging
    log.SetOutput(os.Stderr)
    log.SetFlags(log.LstdFlags | log.Lshortfile)
}

func debugWithLog() {
    log.Println("Debug: entering function")
    log.Printf("Debug: processing item %d", itemID)
    log.Fatal("Debug: critical error occurred")  // Calls os.Exit(1)
}
```

#### spew Package for Deep Inspection
```go
import "github.com/davecgh/go-spew/spew"

func deepDebug() {
    complexData := map[string]interface{}{
        "users": []User{{Name: "Alice"}, {Name: "Bob"}},
        "config": Config{Debug: true, Port: 8080},
    }
    
    // Detailed output with types and addresses
    spew.Dump(complexData)
    
    // Configure spew
    spew.Config.Indent = "  "
    spew.Config.DisablePointerAddresses = true
    spew.Fdump(os.Stderr, complexData)
}
```

### Runtime Debugging

#### runtime Package
```go
import "runtime"

func runtimeDebug() {
    // Print current goroutine stack trace
    buf := make([]byte, 1024)
    n := runtime.Stack(buf, false)
    fmt.Printf("Stack trace:\n%s", buf[:n])
    
    // Print all goroutine stack traces
    allBuf := make([]byte, 1024*1024)
    n = runtime.Stack(allBuf, true)
    fmt.Printf("All goroutines:\n%s", allBuf[:n])
    
    // Get caller information
    if pc, file, line, ok := runtime.Caller(1); ok {
        fn := runtime.FuncForPC(pc)
        fmt.Printf("Called from %s:%d %s\n", file, line, fn.Name())
    }
    
    // Memory statistics
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("Allocated memory: %d KB\n", m.Alloc/1024)
    fmt.Printf("Total allocations: %d\n", m.TotalAlloc)
    fmt.Printf("GC cycles: %d\n", m.NumGC)
}
```

#### debug Package
```go
import "runtime/debug"

func debugInfo() {
    // Get build info
    if info, ok := debug.ReadBuildInfo(); ok {
        fmt.Printf("Module: %s\n", info.Main.Path)
        fmt.Printf("Version: %s\n", info.Main.Version)
        
        for _, dep := range info.Deps {
            fmt.Printf("Dependency: %s@%s\n", dep.Path, dep.Version)
        }
    }
    
    // Force garbage collection
    debug.FreeOSMemory()
    
    // Set GC percentage
    old := debug.SetGCPercent(50)
    fmt.Printf("Previous GC percent: %d\n", old)
    
    // Print stack trace for all goroutines
    debug.PrintStack()
}
```

## Delve Debugger (dlv)

### Installation and Setup
```bash
# Install Delve
go install github.com/go-delve/delve/cmd/dlv@latest

# Verify installation
dlv version
```

### Basic Delve Commands

#### Starting Debug Session
```bash
# Debug current package
dlv debug

# Debug specific package
dlv debug ./cmd/myapp

# Debug with arguments
dlv debug ./cmd/myapp -- --port 8080 --config dev.yaml

# Debug running process
dlv attach <PID>

# Debug test
dlv test ./internal/service

# Debug core dump
dlv core ./binary ./core
```

#### Interactive Debugging Commands
```bash
# Breakpoints
(dlv) break main.main                    # Set breakpoint at function
(dlv) break /path/to/file.go:42         # Set breakpoint at line
(dlv) break *0x400000                   # Set breakpoint at address
(dlv) breakpoints                       # List all breakpoints
(dlv) clear 1                          # Clear breakpoint by ID
(dlv) clearall                         # Clear all breakpoints

# Execution control
(dlv) continue                         # Continue execution
(dlv) next                            # Step over
(dlv) step                            # Step into
(dlv) stepout                         # Step out of current function
(dlv) restart                         # Restart program

# Inspection
(dlv) print variable                   # Print variable value
(dlv) print *pointer                   # Dereference pointer
(dlv) print len(slice)                 # Print slice length
(dlv) locals                          # Show local variables
(dlv) args                            # Show function arguments
(dlv) vars                            # Show package variables

# Stack inspection
(dlv) stack                           # Show call stack
(dlv) frame 1                         # Switch to stack frame
(dlv) up                              # Move up call stack
(dlv) down                            # Move down call stack

# Goroutines
(dlv) goroutines                      # List all goroutines
(dlv) goroutine 1                     # Switch to goroutine
(dlv) goroutine 1 bt                  # Show goroutine stack trace
```

### Advanced Delve Usage

#### Conditional Breakpoints
```bash
# Break when condition is true
(dlv) break main.go:25 count > 100

# Break with complex expression
(dlv) break processUser user.Age >= 18 && user.Status == "active"
```

#### Watchpoints (Data Breakpoints)
```bash
# Watch variable for changes
(dlv) watch -w variable

# Watch memory address
(dlv) watch -r -w *address
```

#### Delve API Server
```bash
# Start headless debugger
dlv debug --headless --listen=:2345 --api-version=2

# Connect from IDE or another dlv instance
dlv connect :2345
```

### Debugging with VS Code

#### VS Code Launch Configuration
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Launch Package",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/myapp",
            "args": ["--port", "8080"],
            "env": {
                "DEBUG": "true"
            },
            "cwd": "${workspaceFolder}",
            "console": "integratedTerminal"
        },
        {
            "name": "Debug test",
            "type": "go",
            "request": "launch",
            "mode": "test",
            "program": "${workspaceFolder}/internal/service",
            "args": ["-test.run", "TestMyFunction"]
        },
        {
            "name": "Attach to process",
            "type": "go",
            "request": "attach",
            "mode": "local",
            "processId": 0
        },
        {
            "name": "Connect to dlv",
            "type": "go",
            "request": "attach",
            "mode": "remote",
            "remotePath": "${workspaceFolder}",
            "port": 2345,
            "host": "localhost"
        }
    ]
}
```

#### VS Code Settings for Go Debugging
```json
{
    "go.delveConfig": {
        "dlvLoadConfig": {
            "followPointers": true,
            "maxVariableRecurse": 3,
            "maxStringLen": 400,
            "maxArrayValues": 400,
            "maxStructFields": -1
        },
        "apiVersion": 2,
        "showGlobalVariables": false
    },
    "go.debugAdapter": "dlv-dap"
}
```

## Remote Debugging

### Debugging in Docker
```dockerfile
# Dockerfile for debugging
FROM golang:1.21-alpine AS debugger

RUN go install github.com/go-delve/delve/cmd/dlv@latest

WORKDIR /app
COPY . .

# Build with debug info
RUN go build -gcflags="all=-N -l" -o app ./cmd/myapp

EXPOSE 8080 2345

# Start with debugger
CMD ["dlv", "exec", "./app", "--headless", "--listen=:2345", "--api-version=2", "--accept-multiclient"]
```

```yaml
# docker-compose.yml for debugging
version: '3.8'
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.debug
    ports:
      - "8080:8080"
      - "2345:2345"
    security_opt:
      - "apparmor:unconfined"
      - "seccomp:unconfined"
    cap_add:
      - SYS_PTRACE
```

### Remote Debugging Setup
```bash
# On remote server
dlv debug --headless --listen=0.0.0.0:2345 --api-version=2 ./cmd/myapp

# From local machine
dlv connect remote-server:2345
```

## Profiling and Performance Debugging

### CPU Profiling

#### Basic CPU Profiling
```go
import (
    "os"
    "runtime/pprof"
)

func cpuProfile() {
    f, err := os.Create("cpu.prof")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    
    if err := pprof.StartCPUProfile(f); err != nil {
        log.Fatal(err)
    }
    defer pprof.StopCPUProfile()
    
    // Your code to profile
    doExpensiveWork()
}
```

#### HTTP Profiling Endpoint
```go
import (
    _ "net/http/pprof"
    "net/http"
    "log"
)

func main() {
    // Enable pprof endpoint
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // Your application code
    startServer()
}
```

#### Analyzing CPU Profiles
```bash
# Collect CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# Interactive analysis
(pprof) top10                          # Top 10 functions by CPU usage
(pprof) list main.expensiveFunction    # Show annotated source
(pprof) web                           # Generate SVG call graph
(pprof) traces                        # Show sample traces
(pprof) disasm main.expensiveFunction # Show assembly code
```

### Memory Profiling

#### Heap Profiling
```go
func memProfile() {
    runtime.GC() // Force GC before profiling
    
    f, err := os.Create("mem.prof")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    
    if err := pprof.WriteHeapProfile(f); err != nil {
        log.Fatal(err)
    }
}
```

#### Memory Analysis
```bash
# Heap profile
go tool pprof http://localhost:6060/debug/pprof/heap

# Allocation profile
go tool pprof http://localhost:6060/debug/pprof/allocs

# Interactive memory analysis
(pprof) top                           # Top allocators
(pprof) list main.leakyFunction       # Show source with allocations
(pprof) web                          # Visualization
(pprof) peek main.leakyFunction      # Quick source view
```

### Goroutine and Blocking Profiling

#### Goroutine Analysis
```bash
# Goroutine profile
go tool pprof http://localhost:6060/debug/pprof/goroutine

# Block profiling (shows where goroutines block)
go tool pprof http://localhost:6060/debug/pprof/block

# Mutex profiling
go tool pprof http://localhost:6060/debug/pprof/mutex
```

#### Enabling Block and Mutex Profiling
```go
import "runtime"

func init() {
    // Enable block profiling
    runtime.SetBlockProfileRate(1)
    
    // Enable mutex profiling
    runtime.SetMutexProfileFraction(1)
}
```

### Trace Analysis

#### Generating Traces
```go
import (
    "os"
    "runtime/trace"
)

func traceExample() {
    f, err := os.Create("trace.out")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    
    if err := trace.Start(f); err != nil {
        log.Fatal(err)
    }
    defer trace.Stop()
    
    // Code to trace
    doComplexWork()
}
```

#### Analyzing Traces
```bash
# Generate trace
go test -trace=trace.out

# View trace
go tool trace trace.out

# This opens a web interface with:
# - Goroutine analysis
# - Network blocking
# - Synchronization blocking
# - Syscall blocking
# - Scheduler latency
```

## Testing and Debugging

### Debugging Tests

#### Test-specific Debugging
```go
func TestWithDebugging(t *testing.T) {
    // Set up debugging
    if testing.Verbose() {
        log.SetOutput(os.Stderr)
        log.SetFlags(log.LstdFlags | log.Lshortfile)
    }
    
    // Debug test
    t.Logf("Debug: testing with input %v", input)
    
    result := functionUnderTest(input)
    
    if result != expected {
        t.Errorf("Expected %v, got %v", expected, result)
        // Additional debugging on failure
        t.Logf("Debug info: %#v", additionalContext)
    }
}
```

#### Running Tests with Debugging
```bash
# Run tests with verbose output
go test -v

# Run specific test with debugging
go test -v -run TestMyFunction

# Debug test with dlv
dlv test -- -test.run TestMyFunction

# Test with race detection
go test -race -v

# Test with CPU profiling
go test -cpuprofile=cpu.prof -bench=.
```

### Table-driven Test Debugging
```go
func TestMultipleCases(t *testing.T) {
    tests := []struct {
        name     string
        input    Input
        expected Output
        debug    bool  // Enable debugging for specific case
    }{
        {"normal case", Input{A: 1, B: 2}, Output{Sum: 3}, false},
        {"edge case", Input{A: 0, B: 0}, Output{Sum: 0}, true},
        {"negative", Input{A: -1, B: 1}, Output{Sum: 0}, false},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if tt.debug {
                t.Logf("Debug: running %s with input %#v", tt.name, tt.input)
            }
            
            result := functionUnderTest(tt.input)
            
            if !reflect.DeepEqual(result, tt.expected) {
                t.Errorf("Test %s failed: expected %v, got %v", tt.name, tt.expected, result)
                if tt.debug {
                    t.Logf("Debug: detailed analysis...")
                    // Additional debugging
                }
            }
        })
    }
}
```

## Concurrency Debugging

### Race Detection
```bash
# Build with race detector
go build -race ./cmd/myapp

# Run tests with race detection
go test -race ./...

# Run program with race detection
go run -race main.go
```

### Debugging Goroutines

#### Goroutine Leak Detection
```go
import (
    "runtime"
    "testing"
    "time"
)

func TestNoGoroutineLeak(t *testing.T) {
    before := runtime.NumGoroutine()
    
    // Start your goroutines
    done := make(chan bool)
    go worker(done)
    
    // Signal completion
    done <- true
    
    // Wait for cleanup
    time.Sleep(100 * time.Millisecond)
    
    after := runtime.NumGoroutine()
    if after > before {
        t.Errorf("Goroutine leak detected: before=%d, after=%d", before, after)
        
        // Debug: print all goroutines
        buf := make([]byte, 1024*1024)
        n := runtime.Stack(buf, true)
        t.Logf("Goroutine dump:\n%s", buf[:n])
    }
}
```

#### Channel Debugging
```go
func debugChannels() {
    ch := make(chan int, 5)
    
    // Debug channel state
    fmt.Printf("Channel length: %d\n", len(ch))
    fmt.Printf("Channel capacity: %d\n", cap(ch))
    
    // Detect channel issues
    select {
    case ch <- 42:
        fmt.Println("Sent successfully")
    case <-time.After(time.Second):
        fmt.Println("Channel send blocked for 1 second")
    }
    
    select {
    case val := <-ch:
        fmt.Printf("Received: %d\n", val)
    case <-time.After(time.Second):
        fmt.Println("Channel receive blocked for 1 second")
    }
}
```

### Deadlock Detection
```go
import "time"

func detectDeadlock() {
    // Set up deadlock detection
    timeout := time.After(5 * time.Second)
    done := make(chan bool)
    
    go func() {
        // Potentially deadlocking code
        dangerousOperation()
        done <- true
    }()
    
    select {
    case <-done:
        fmt.Println("Operation completed successfully")
    case <-timeout:
        fmt.Println("Potential deadlock detected!")
        
        // Dump goroutine stacks
        buf := make([]byte, 1024*1024)
        n := runtime.Stack(buf, true)
        fmt.Printf("Goroutine dump:\n%s", buf[:n])
        
        panic("deadlock detected")
    }
}
```

## Advanced Debugging Techniques

### Custom Debug Middleware
```go
func debugMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // Log request
        log.Printf("Request: %s %s", r.Method, r.URL.Path)
        
        // Wrap response writer to capture status
        rw := &responseWriter{ResponseWriter: w, statusCode: 200}
        
        // Call next handler
        next.ServeHTTP(rw, r)
        
        // Log response
        duration := time.Since(start)
        log.Printf("Response: %d in %v", rw.statusCode, duration)
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}
```

### Build Tags for Debug Code
```go
// debug.go
// +build debug

package main

import "log"

func debugLog(msg string) {
    log.Printf("DEBUG: %s", msg)
}

const debugEnabled = true
```

```go
// release.go
// +build !debug

package main

func debugLog(msg string) {
    // No-op in release builds
}

const debugEnabled = false
```

```bash
# Build with debug enabled
go build -tags debug

# Build without debug (default)
go build
```

### Environment-based Debugging
```go
import "os"

func setupDebugging() {
    if os.Getenv("DEBUG") == "true" {
        log.SetLevel(log.DebugLevel)
        
        // Enable pprof in debug mode
        go func() {
            log.Println(http.ListenAndServe("localhost:6060", nil))
        }()
    }
    
    if level := os.Getenv("LOG_LEVEL"); level != "" {
        setLogLevel(level)
    }
}
```

## Debugging Best Practices

### 1. Systematic Debugging Approach
```go
func debugSystematically() {
    // 1. Reproduce the issue consistently
    // 2. Isolate the problem
    // 3. Use appropriate tools
    // 4. Form hypotheses and test them
    // 5. Fix and verify
    
    log.Printf("Starting debug session at %v", time.Now())
    defer log.Printf("Ending debug session at %v", time.Now())
    
    // Your debugging code here
}
```

### 2. Structured Logging for Debugging
```go
import "go.uber.org/zap"

func structuredDebugLogging() {
    logger, _ := zap.NewDevelopment()
    defer logger.Sync()
    
    sugar := logger.Sugar()
    
    sugar.Debugw("Processing user",
        "userID", 12345,
        "operation", "login",
        "timestamp", time.Now(),
    )
    
    // Conditional debug logging
    if debugEnabled {
        sugar.Debugw("Detailed state",
            "variables", map[string]interface{}{
                "counter": counter,
                "status":  status,
            },
        )
    }
}
```

### 3. Debug Helpers and Utilities
```go
// debug_helpers.go
package debug

import (
    "fmt"
    "runtime"
    "strings"
)

func FuncName() string {
    pc, _, _, _ := runtime.Caller(1)
    fn := runtime.FuncForPC(pc)
    return fn.Name()
}

func Location() string {
    _, file, line, _ := runtime.Caller(1)
    parts := strings.Split(file, "/")
    return fmt.Sprintf("%s:%d", parts[len(parts)-1], line)
}

func StackTrace() string {
    buf := make([]byte, 1024)
    n := runtime.Stack(buf, false)
    return string(buf[:n])
}

// Usage
func someFunction() {
    log.Printf("Entering %s at %s", debug.FuncName(), debug.Location())
    defer log.Printf("Exiting %s", debug.FuncName())
    
    // Function logic
}
```

### 4. Error Context for Debugging
```go
import "github.com/pkg/errors"

func processWithContext() error {
    userID := getCurrentUser()
    
    err := validateUser(userID)
    if err != nil {
        return errors.Wrapf(err, "validation failed for user %d", userID)
    }
    
    err = processUser(userID)
    if err != nil {
        return errors.Wrapf(err, "processing failed for user %d at step %s", userID, "process")
    }
    
    return nil
}

// Error handling with stack trace
func handleError(err error) {
    if err != nil {
        log.Printf("Error: %+v", err)  // Includes stack trace with pkg/errors
    }
}
```

This comprehensive debugging guide provides all the tools and techniques needed to effectively debug Go applications, from simple print statements to advanced profiling and distributed debugging scenarios.

## References
- [Delve Debugger Documentation](https://github.com/go-delve/delve/tree/master/Documentation)
- [Go Profiling](https://go.dev/blog/pprof)
- [Debugging Go Code with GDB](https://go.dev/doc/gdb)
- [Go Execution Tracer](https://go.dev/blog/execution-tracer)
- [VS Code Go Extension](https://github.com/golang/vscode-go)