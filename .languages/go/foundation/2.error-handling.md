# Go Error Handling

## Core Philosophy
Go takes a unique approach to error handling: **explicit is better than implicit**. Instead of exceptions, Go uses explicit error values that must be checked.

## The Error Interface
```go
type error interface {
    Error() string
}
```

Any type that implements the `Error()` method satisfies the error interface.

## Basic Error Handling Patterns

### Standard Error Checking
```go
result, err := someFunction()
if err != nil {
    // Handle error
    return err  // or wrap it
}
// Use result
```

### Creating Errors

#### Using errors.New
```go
import "errors"

var ErrNotFound = errors.New("item not found")

func findItem(id string) (*Item, error) {
    // ... search logic
    if !found {
        return nil, ErrNotFound
    }
    return item, nil
}
```

#### Using fmt.Errorf
```go
import "fmt"

func validate(age int) error {
    if age < 0 {
        return fmt.Errorf("invalid age: %d", age)
    }
    return nil
}
```

### Error Wrapping (Go 1.13+)

#### Wrapping Errors
```go
import "fmt"

func processFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("failed to process file %s: %w", filename, err)
    }
    defer file.Close()
    // ... process
    return nil
}
```

#### Unwrapping Errors
```go
import "errors"

// Check if error is or wraps a specific error
if errors.Is(err, os.ErrNotExist) {
    // Handle file not exist
}

// Extract specific error type
var pathErr *os.PathError
if errors.As(err, &pathErr) {
    fmt.Printf("Failed at path: %s\n", pathErr.Path)
}
```

## Custom Error Types

### Simple Custom Error
```go
type ValidationError struct {
    Field string
    Value interface{}
    Msg   string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("validation failed for field %s with value %v: %s", 
        e.Field, e.Value, e.Msg)
}
```

### Error with Additional Context
```go
type APIError struct {
    Code    int
    Message string
    Details map[string]interface{}
}

func (e APIError) Error() string {
    return fmt.Sprintf("API error %d: %s", e.Code, e.Message)
}

// Usage
func makeAPICall() error {
    // ... API call logic
    if respCode != 200 {
        return APIError{
            Code:    respCode,
            Message: "request failed",
            Details: map[string]interface{}{
                "endpoint": "/api/users",
                "method":   "GET",
            },
        }
    }
    return nil
}
```

## Error Handling Strategies

### Early Return Pattern
```go
func processData(data []byte) error {
    if len(data) == 0 {
        return errors.New("empty data")
    }
    
    parsed, err := parseData(data)
    if err != nil {
        return fmt.Errorf("parse failed: %w", err)
    }
    
    validated, err := validateData(parsed)
    if err != nil {
        return fmt.Errorf("validation failed: %w", err)
    }
    
    return saveData(validated)
}
```

### Error Aggregation
```go
type MultiError struct {
    Errors []error
}

func (m MultiError) Error() string {
    var msgs []string
    for _, err := range m.Errors {
        msgs = append(msgs, err.Error())
    }
    return strings.Join(msgs, "; ")
}

func validateAll(items []Item) error {
    var errs MultiError
    for i, item := range items {
        if err := item.Validate(); err != nil {
            errs.Errors = append(errs.Errors, 
                fmt.Errorf("item %d: %w", i, err))
        }
    }
    if len(errs.Errors) > 0 {
        return errs
    }
    return nil
}
```

### Retry with Exponential Backoff
```go
func retryOperation(fn func() error, maxRetries int) error {
    var err error
    backoff := time.Second
    
    for i := 0; i < maxRetries; i++ {
        if err = fn(); err == nil {
            return nil
        }
        
        if i < maxRetries-1 {
            time.Sleep(backoff)
            backoff *= 2
        }
    }
    
    return fmt.Errorf("operation failed after %d retries: %w", maxRetries, err)
}
```

## Sentinel Errors

### Defining Sentinel Errors
```go
package mypackage

import "errors"

var (
    ErrNotFound   = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrTimeout    = errors.New("operation timed out")
)

// Check against sentinel errors
if errors.Is(err, ErrNotFound) {
    // Handle not found case
}
```

### Standard Library Sentinel Errors
```go
import (
    "io"
    "os"
    "database/sql"
)

// Common sentinel errors
io.EOF              // End of file
os.ErrNotExist      // File doesn't exist
os.ErrPermission    // Permission denied
sql.ErrNoRows       // No rows in result set
context.Canceled    // Context was canceled
context.DeadlineExceeded // Context deadline exceeded
```

## Panic and Recover

### When to Panic
Panic should be used sparingly, only for:
- Unrecoverable programming errors
- Initialization failures
- Impossible conditions

```go
func mustInitialize(config Config) {
    if err := initialize(config); err != nil {
        panic(fmt.Sprintf("initialization failed: %v", err))
    }
}
```

### Recover from Panic
```go
func safeOperation() (err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic recovered: %v", r)
            // Log stack trace
            debug.PrintStack()
        }
    }()
    
    // Potentially panicking code
    riskyOperation()
    return nil
}
```

## Error Handling Best Practices

### 1. Always Check Errors
```go
// Bad
result, _ := someFunction()

// Good
result, err := someFunction()
if err != nil {
    return fmt.Errorf("someFunction failed: %w", err)
}
```

### 2. Add Context When Wrapping
```go
// Bad
if err != nil {
    return err
}

// Good
if err != nil {
    return fmt.Errorf("failed to process user %d: %w", userID, err)
}
```

### 3. Define Package-Level Errors
```go
package user

var (
    ErrNotFound = errors.New("user not found")
    ErrDuplicate = errors.New("user already exists")
    ErrInvalidEmail = errors.New("invalid email format")
)
```

### 4. Use Type Assertions for Behavior
```go
type temporary interface {
    Temporary() bool
}

func shouldRetry(err error) bool {
    if err == nil {
        return false
    }
    
    var tempErr temporary
    if errors.As(err, &tempErr) {
        return tempErr.Temporary()
    }
    
    return false
}
```

### 5. Log Errors Once
```go
func handleRequest(w http.ResponseWriter, r *http.Request) {
    if err := processRequest(r); err != nil {
        log.Printf("request processing failed: %v", err)
        http.Error(w, "Internal Server Error", 500)
        return  // Don't return the error, it's already logged
    }
}
```

## Error Handling in Different Contexts

### HTTP Handlers
```go
func userHandler(w http.ResponseWriter, r *http.Request) {
    user, err := getUser(r.Context(), r.URL.Path[1:])
    if err != nil {
        switch {
        case errors.Is(err, ErrNotFound):
            http.Error(w, "User not found", http.StatusNotFound)
        case errors.Is(err, ErrUnauthorized):
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
        default:
            log.Printf("unexpected error: %v", err)
            http.Error(w, "Internal server error", http.StatusInternalServerError)
        }
        return
    }
    
    json.NewEncoder(w).Encode(user)
}
```

### Database Operations
```go
import "database/sql"

func getUser(id int) (*User, error) {
    var user User
    err := db.QueryRow("SELECT * FROM users WHERE id = ?", id).Scan(&user.ID, &user.Name)
    
    switch {
    case err == sql.ErrNoRows:
        return nil, ErrNotFound
    case err != nil:
        return nil, fmt.Errorf("database query failed: %w", err)
    }
    
    return &user, nil
}
```

### Concurrent Operations
```go
func fetchAll(urls []string) ([]Result, error) {
    type result struct {
        url string
        res Result
        err error
    }
    
    ch := make(chan result, len(urls))
    
    for _, url := range urls {
        go func(u string) {
            res, err := fetch(u)
            ch <- result{url: u, res: res, err: err}
        }(url)
    }
    
    var results []Result
    var errs MultiError
    
    for range urls {
        r := <-ch
        if r.err != nil {
            errs.Errors = append(errs.Errors, 
                fmt.Errorf("fetch %s: %w", r.url, r.err))
        } else {
            results = append(results, r.res)
        }
    }
    
    if len(errs.Errors) > 0 {
        return results, errs
    }
    return results, nil
}
```

## Testing Error Conditions

```go
func TestDivide(t *testing.T) {
    tests := []struct {
        name    string
        a, b    float64
        want    float64
        wantErr bool
    }{
        {"positive", 10, 2, 5, false},
        {"negative", -10, 2, -5, false},
        {"zero division", 10, 0, 0, true},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := divide(tt.a, tt.b)
            if (err != nil) != tt.wantErr {
                t.Errorf("divide() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !tt.wantErr && got != tt.want {
                t.Errorf("divide() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

## References
- [Error Handling in Go](https://go.dev/blog/error-handling-and-go)
- [Working with Errors in Go 1.13](https://go.dev/blog/go1.13-errors)
- [Effective Go - Errors](https://go.dev/doc/effective_go#errors)
- [Go Error Handling Best Practices](https://github.com/golang/go/wiki/ErrorValueFAQ)