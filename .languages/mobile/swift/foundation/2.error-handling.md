# Swift Error Handling for Mobile Development

## Error Handling Philosophy

Swift's error handling system is designed for safety and clarity, making it ideal for mobile development where crashes can severely impact user experience. Swift uses typed errors that must be explicitly handled, preventing many runtime crashes common in mobile applications.

## Error Types and Protocols

### Error Protocol
```swift
// All error types must conform to Error protocol
protocol Error {
    // No required methods - just a marker protocol
}

// Built-in error types
enum ValidationError: Error {
    case emptyField(fieldName: String)
    case invalidFormat(fieldName: String)
    case tooShort(fieldName: String, minimumLength: Int)
    case tooLong(fieldName: String, maximumLength: Int)
}

// LocalizedError for user-facing messages
enum NetworkError: LocalizedError {
    case noConnection
    case timeout
    case serverError(code: Int, message: String)
    case invalidResponse
    case dataCorrupted
    
    var errorDescription: String? {
        switch self {
        case .noConnection:
            return NSLocalizedString("No internet connection", comment: "Network error")
        case .timeout:
            return NSLocalizedString("Request timed out", comment: "Network error")
        case .serverError(_, let message):
            return message
        case .invalidResponse:
            return NSLocalizedString("Invalid server response", comment: "Network error")
        case .dataCorrupted:
            return NSLocalizedString("Data is corrupted", comment: "Network error")
        }
    }
    
    var failureReason: String? {
        switch self {
        case .noConnection:
            return "The device is not connected to the internet"
        case .timeout:
            return "The server took too long to respond"
        case .serverError(let code, _):
            return "Server returned error code \(code)"
        case .invalidResponse:
            return "Server response format is invalid"
        case .dataCorrupted:
            return "Received data cannot be processed"
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .noConnection:
            return "Please check your internet connection and try again"
        case .timeout:
            return "Please try again in a moment"
        case .serverError:
            return "Please contact support if the problem persists"
        case .invalidResponse, .dataCorrupted:
            return "Please update the app to the latest version"
        }
    }
}
```

### Custom Error Types for Mobile Development
```swift
// Core Data errors
enum CoreDataError: Error, LocalizedError {
    case contextNotFound
    case entityNotFound(String)
    case saveFailed(underlyingError: Error)
    case fetchFailed(underlyingError: Error)
    case migrationFailed
    
    var errorDescription: String? {
        switch self {
        case .contextNotFound:
            return "Database context not available"
        case .entityNotFound(let entityName):
            return "Entity '\(entityName)' not found"
        case .saveFailed(let error):
            return "Failed to save data: \(error.localizedDescription)"
        case .fetchFailed(let error):
            return "Failed to fetch data: \(error.localizedDescription)"
        case .migrationFailed:
            return "Database migration failed"
        }
    }
}

// Authentication errors
enum AuthenticationError: Error, LocalizedError {
    case userNotFound
    case invalidCredentials
    case accountLocked
    case sessionExpired
    case biometricNotAvailable
    case biometricFailed
    case tokenExpired
    
    var errorDescription: String? {
        switch self {
        case .userNotFound:
            return "User account not found"
        case .invalidCredentials:
            return "Invalid username or password"
        case .accountLocked:
            return "Account is temporarily locked"
        case .sessionExpired:
            return "Session has expired"
        case .biometricNotAvailable:
            return "Biometric authentication not available"
        case .biometricFailed:
            return "Biometric authentication failed"
        case .tokenExpired:
            return "Authentication token expired"
        }
    }
}

// Image processing errors
enum ImageError: Error, LocalizedError {
    case invalidData
    case processingFailed
    case unsupportedFormat
    case fileTooLarge(maxSize: Int)
    case compressionFailed
    
    var errorDescription: String? {
        switch self {
        case .invalidData:
            return "Image data is invalid"
        case .processingFailed:
            return "Failed to process image"
        case .unsupportedFormat:
            return "Unsupported image format"
        case .fileTooLarge(let maxSize):
            return "Image file too large (max: \(maxSize)MB)"
        case .compressionFailed:
            return "Failed to compress image"
        }
    }
}
```

## Error Throwing and Handling

### Basic Error Throwing
```swift
// Throwing functions
func validateUser(name: String, email: String) throws {
    guard !name.isEmpty else {
        throw ValidationError.emptyField(fieldName: "name")
    }
    
    guard email.contains("@") else {
        throw ValidationError.invalidFormat(fieldName: "email")
    }
    
    guard name.count >= 2 else {
        throw ValidationError.tooShort(fieldName: "name", minimumLength: 2)
    }
}

// Function with return value that can throw
func parseUserData(from json: Data) throws -> User {
    guard !json.isEmpty else {
        throw NetworkError.dataCorrupted
    }
    
    do {
        return try JSONDecoder().decode(User.self, from: json)
    } catch {
        throw NetworkError.dataCorrupted
    }
}

// Async throwing function (iOS 15+)
func fetchUserProfile(userID: String) async throws -> UserProfile {
    guard !userID.isEmpty else {
        throw ValidationError.emptyField(fieldName: "userID")
    }
    
    let url = URL(string: "https://api.example.com/users/\(userID)")!
    
    do {
        let (data, response) = try await URLSession.shared.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }
        
        guard 200...299 ~= httpResponse.statusCode else {
            throw NetworkError.serverError(code: httpResponse.statusCode, message: "Server error")
        }
        
        return try JSONDecoder().decode(UserProfile.self, from: data)
    } catch is DecodingError {
        throw NetworkError.dataCorrupted
    } catch {
        throw NetworkError.noConnection
    }
}
```

### Do-Try-Catch Pattern
```swift
// Basic do-try-catch
func handleUserRegistration(name: String, email: String) {
    do {
        try validateUser(name: name, email: email)
        let user = User(name: name, email: email)
        try saveUser(user)
        showSuccessMessage("User registered successfully")
    } catch ValidationError.emptyField(let fieldName) {
        showError("Please fill in the \(fieldName) field")
    } catch ValidationError.invalidFormat(let fieldName) {
        showError("Please enter a valid \(fieldName)")
    } catch ValidationError.tooShort(let fieldName, let minLength) {
        showError("\(fieldName.capitalized) must be at least \(minLength) characters")
    } catch CoreDataError.saveFailed {
        showError("Failed to save user data. Please try again.")
    } catch {
        showError("An unexpected error occurred: \(error.localizedDescription)")
    }
}

// Multiple try statements
func processUserData() {
    do {
        let userData = try loadUserData()
        let parsedUser = try parseUserData(from: userData)
        let validatedUser = try validateUserProfile(parsedUser)
        try saveToDatabase(validatedUser)
        updateUI(with: validatedUser)
    } catch let error as NetworkError {
        handleNetworkError(error)
    } catch let error as ValidationError {
        handleValidationError(error)
    } catch let error as CoreDataError {
        handleDatabaseError(error)
    } catch {
        handleUnknownError(error)
    }
}
```

### Try Variants
```swift
// Force try (use sparingly, only when certain it won't throw)
let user = try! parseUserData(from: knownValidData)

// Optional try (returns nil if error occurs)
if let user = try? parseUserData(from: jsonData) {
    updateUI(with: user)
} else {
    showError("Failed to parse user data")
}

// Chain optional try
let userName = try? parseUserData(from: jsonData)?.name
let profileImage = try? loadImage(from: imageURL)

// Using optional try with nil coalescing
let user = try? parseUserData(from: jsonData) ?? User.defaultUser
```

### Guard with Try
```swift
func processUserLogin(credentials: LoginCredentials) {
    // Guard with throwing function
    guard let validCredentials = try? validateCredentials(credentials) else {
        showError("Invalid login credentials")
        return
    }
    
    // Guard with optional try
    guard let token = try? authenticateUser(validCredentials) else {
        showError("Authentication failed")
        return
    }
    
    // Continue with successful authentication
    UserSession.current.setAuthToken(token)
    navigateToMainScreen()
}
```

## Result Type Pattern

### Result Type for Non-Throwing APIs
```swift
// Network service using Result type
class NetworkService {
    enum NetworkResult<T> {
        case success(T)
        case failure(NetworkError)
    }
    
    func fetchUser(id: String, completion: @escaping (Result<User, NetworkError>) -> Void) {
        guard !id.isEmpty else {
            completion(.failure(.invalidResponse))
            return
        }
        
        URLSession.shared.dataTask(with: userURL(for: id)) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(.failure(.noConnection))
                    return
                }
                
                guard let data = data else {
                    completion(.failure(.dataCorrupted))
                    return
                }
                
                do {
                    let user = try JSONDecoder().decode(User.self, from: data)
                    completion(.success(user))
                } catch {
                    completion(.failure(.dataCorrupted))
                }
            }
        }.resume()
    }
}

// Using Result type
class UserViewController: UIViewController {
    private let networkService = NetworkService()
    
    func loadUser(id: String) {
        showLoadingIndicator()
        
        networkService.fetchUser(id: id) { [weak self] result in
            self?.hideLoadingIndicator()
            
            switch result {
            case .success(let user):
                self?.updateUI(with: user)
            case .failure(let error):
                self?.handleNetworkError(error)
            }
        }
    }
    
    private func handleNetworkError(_ error: NetworkError) {
        let alertController = UIAlertController(
            title: "Error",
            message: error.localizedDescription,
            preferredStyle: .alert
        )
        
        alertController.addAction(UIAlertAction(title: "Retry", style: .default) { _ in
            // Retry logic
        })
        
        alertController.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        
        present(alertController, animated: true)
    }
}
```

### Converting Between Result and Throws
```swift
extension Result {
    // Convert Result to throwing function
    func get() throws -> Success {
        switch self {
        case .success(let value):
            return value
        case .failure(let error):
            throw error
        }
    }
}

// Convert throwing function to Result
func resultify<T>(_ throwingFunction: () throws -> T) -> Result<T, Error> {
    do {
        let value = try throwingFunction()
        return .success(value)
    } catch {
        return .failure(error)
    }
}

// Usage
let parseResult = resultify { try parseUserData(from: jsonData) }
```

## Async/Await Error Handling

### Async Error Handling Patterns
```swift
// Basic async error handling
func loadUserProfile() async {
    do {
        let profile = try await fetchUserProfile(userID: currentUserID)
        await updateUI(with: profile)
    } catch let error as NetworkError {
        await showNetworkError(error)
    } catch {
        await showUnknownError(error)
    }
}

// Multiple async operations with error handling
func refreshAllData() async throws {
    // These run concurrently
    async let userTask = fetchUserProfile(userID: currentUserID)
    async let settingsTask = fetchUserSettings(userID: currentUserID)
    async let notificationsTask = fetchNotifications()
    
    // Wait for all to complete (any failure will throw)
    let (user, settings, notifications) = try await (userTask, settingsTask, notificationsTask)
    
    // Update UI with all data
    await updateUI(user: user, settings: settings, notifications: notifications)
}

// Error handling with TaskGroup
func loadMultipleUsers(userIDs: [String]) async throws -> [User] {
    return try await withThrowingTaskGroup(of: User.self) { group in
        for userID in userIDs {
            group.addTask {
                try await fetchUserProfile(userID: userID)
            }
        }
        
        var users: [User] = []
        for try await user in group {
            users.append(user)
        }
        return users
    }
}
```

### SwiftUI Error Handling
```swift
// SwiftUI view with async error handling
struct UserProfileView: View {
    let userID: String
    @State private var user: User?
    @State private var errorMessage: String?
    @State private var isLoading = false
    
    var body: some View {
        Group {
            if isLoading {
                ProgressView("Loading profile...")
            } else if let user = user {
                ProfileDetailView(user: user)
            } else if let errorMessage = errorMessage {
                ErrorView(message: errorMessage) {
                    Task {
                        await loadUser()
                    }
                }
            } else {
                Text("No data available")
            }
        }
        .task {
            await loadUser()
        }
        .refreshable {
            await loadUser()
        }
    }
    
    private func loadUser() async {
        isLoading = true
        errorMessage = nil
        
        defer { isLoading = false }
        
        do {
            user = try await fetchUserProfile(userID: userID)
        } catch let error as NetworkError {
            errorMessage = error.localizedDescription
        } catch {
            errorMessage = "An unexpected error occurred"
        }
    }
}

// Error view component
struct ErrorView: View {
    let message: String
    let retryAction: () -> Void
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle")
                .font(.largeTitle)
                .foregroundColor(.orange)
            
            Text(message)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            Button("Try Again") {
                retryAction()
            }
            .buttonStyle(.borderedProminent)
        }
        .padding()
    }
}
```

## Error Recovery and Resilience

### Retry Mechanisms
```swift
// Retry with exponential backoff
func performWithRetry<T>(
    maxAttempts: Int = 3,
    baseDelay: TimeInterval = 1.0,
    operation: @escaping () async throws -> T
) async throws -> T {
    var lastError: Error?
    
    for attempt in 1...maxAttempts {
        do {
            return try await operation()
        } catch {
            lastError = error
            
            // Don't retry on the last attempt
            guard attempt < maxAttempts else { break }
            
            // Calculate delay with exponential backoff
            let delay = baseDelay * pow(2.0, Double(attempt - 1))
            try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
        }
    }
    
    throw lastError ?? NetworkError.timeout
}

// Usage
func reliableFetchUser(id: String) async throws -> User {
    return try await performWithRetry(maxAttempts: 3) {
        try await fetchUserProfile(userID: id)
    }
}
```

### Circuit Breaker Pattern
```swift
class CircuitBreaker {
    enum State {
        case closed
        case open
        case halfOpen
    }
    
    private var state: State = .closed
    private var failureCount = 0
    private var lastFailureTime: Date?
    private let failureThreshold: Int
    private let timeout: TimeInterval
    
    init(failureThreshold: Int = 5, timeout: TimeInterval = 60) {
        self.failureThreshold = failureThreshold
        self.timeout = timeout
    }
    
    func execute<T>(_ operation: @escaping () async throws -> T) async throws -> T {
        switch state {
        case .open:
            if shouldAttemptReset() {
                state = .halfOpen
            } else {
                throw NetworkError.serverError(code: 503, message: "Circuit breaker is open")
            }
            
        case .closed, .halfOpen:
            break
        }
        
        do {
            let result = try await operation()
            onSuccess()
            return result
        } catch {
            onFailure()
            throw error
        }
    }
    
    private func onSuccess() {
        failureCount = 0
        state = .closed
    }
    
    private func onFailure() {
        failureCount += 1
        lastFailureTime = Date()
        
        if failureCount >= failureThreshold {
            state = .open
        }
    }
    
    private func shouldAttemptReset() -> Bool {
        guard let lastFailure = lastFailureTime else { return false }
        return Date().timeIntervalSince(lastFailure) >= timeout
    }
}
```

### Graceful Degradation
```swift
class ContentService {
    private let networkService = NetworkService()
    private let cacheService = CacheService()
    private let circuitBreaker = CircuitBreaker()
    
    func loadContent() async -> ContentResult {
        // Try network first
        do {
            let content = try await circuitBreaker.execute {
                try await networkService.fetchLatestContent()
            }
            
            // Cache successful result
            await cacheService.store(content)
            return .success(content, source: .network)
            
        } catch {
            // Fallback to cache
            if let cachedContent = await cacheService.getCachedContent() {
                return .success(cachedContent, source: .cache)
            }
            
            // Final fallback to default content
            return .success(ContentService.defaultContent, source: .default)
        }
    }
}

enum ContentResult {
    case success(Content, source: ContentSource)
    
    enum ContentSource {
        case network
        case cache
        case `default`
    }
}
```

## Error Reporting and Logging

### Structured Error Logging
```swift
import os.log

class ErrorLogger {
    private static let subsystem = "com.myapp.main"
    private static let category = "error-handling"
    private static let logger = Logger(subsystem: subsystem, category: category)
    
    static func logError(
        _ error: Error,
        context: String,
        file: String = #file,
        function: String = #function,
        line: Int = #line
    ) {
        let fileName = URL(fileURLWithPath: file).lastPathComponent
        let logMessage = """
        Error in \(context):
        File: \(fileName)
        Function: \(function)
        Line: \(line)
        Error: \(error.localizedDescription)
        """
        
        logger.error("\(logMessage)")
        
        // Send to crash reporting service
        CrashReporter.recordError(error, context: context)
    }
}

// Usage
func processUserData() {
    do {
        try performDataProcessing()
    } catch {
        ErrorLogger.logError(error, context: "User data processing")
        showUserFriendlyError(error)
    }
}
```

### Error Analytics
```swift
class ErrorAnalytics {
    static func trackError(
        _ error: Error,
        screen: String,
        userID: String?,
        additionalInfo: [String: Any] = [:]
    ) {
        var parameters: [String: Any] = [
            "error_type": String(describing: type(of: error)),
            "error_description": error.localizedDescription,
            "screen": screen,
            "timestamp": ISO8601DateFormatter().string(from: Date())
        ]
        
        if let userID = userID {
            parameters["user_id"] = userID
        }
        
        parameters.merge(additionalInfo) { _, new in new }
        
        AnalyticsService.track(event: "error_occurred", parameters: parameters)
    }
}
```

## Best Practices for Mobile Error Handling

### User Experience Guidelines
```swift
// Show user-friendly error messages
func showUserFriendlyError(_ error: Error) {
    let (title, message, actions) = friendlyErrorPresentation(for: error)
    
    let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
    
    for action in actions {
        alert.addAction(action)
    }
    
    present(alert, animated: true)
}

func friendlyErrorPresentation(for error: Error) -> (String, String, [UIAlertAction]) {
    switch error {
    case NetworkError.noConnection:
        return (
            "No Internet Connection",
            "Please check your internet connection and try again.",
            [
                UIAlertAction(title: "Retry", style: .default) { _ in self.retryLastOperation() },
                UIAlertAction(title: "Go Offline", style: .default) { _ in self.enterOfflineMode() },
                UIAlertAction(title: "Cancel", style: .cancel)
            ]
        )
        
    case AuthenticationError.sessionExpired:
        return (
            "Session Expired",
            "Your session has expired. Please sign in again.",
            [
                UIAlertAction(title: "Sign In", style: .default) { _ in self.showSignInScreen() },
                UIAlertAction(title: "Cancel", style: .cancel)
            ]
        )
        
    default:
        return (
            "Something Went Wrong",
            "An unexpected error occurred. Please try again.",
            [
                UIAlertAction(title: "Retry", style: .default) { _ in self.retryLastOperation() },
                UIAlertAction(title: "Cancel", style: .cancel)
            ]
        )
    }
}
```

### Performance Considerations
```swift
// Lazy error message computation
enum PerformanceError: Error {
    case operationTooSlow(duration: TimeInterval)
    case memoryPressure(availableMemory: UInt64)
    
    var localizedDescription: String {
        switch self {
        case .operationTooSlow(let duration):
            return "Operation took \(String(format: "%.2f", duration)) seconds (too slow)"
        case .memoryPressure(let available):
            let mb = available / (1024 * 1024)
            return "Low memory: only \(mb)MB available"
        }
    }
}

// Efficient error handling for high-frequency operations
func efficientErrorHandling() {
    // Pre-allocate error objects for common cases
    let commonErrors = [
        NetworkError.noConnection,
        NetworkError.timeout,
        NetworkError.serverError(code: 500, message: "Server Error")
    ]
    
    // Use error caching to avoid repeated string formatting
    let errorCache = NSCache<NSString, NSString>()
    
    func getCachedErrorMessage(for error: Error) -> String {
        let key = String(describing: error) as NSString
        
        if let cached = errorCache.object(forKey: key) {
            return cached as String
        }
        
        let message = error.localizedDescription
        errorCache.setObject(message as NSString, forKey: key)
        return message
    }
}
```

## Testing Error Handling

### Unit Testing Errors
```swift
import XCTest

class ErrorHandlingTests: XCTestCase {
    func testValidationErrorHandling() {
        XCTAssertThrowsError(try validateUser(name: "", email: "test@example.com")) { error in
            guard case ValidationError.emptyField(let fieldName) = error else {
                XCTFail("Expected ValidationError.emptyField")
                return
            }
            XCTAssertEqual(fieldName, "name")
        }
    }
    
    func testNetworkErrorRecovery() async throws {
        let mockService = MockNetworkService()
        mockService.shouldFail = true
        
        do {
            _ = try await mockService.fetchUser(id: "123")
            XCTFail("Expected error to be thrown")
        } catch NetworkError.noConnection {
            // Expected error
        } catch {
            XCTFail("Unexpected error: \(error)")
        }
    }
}
```

## References
- [Error Handling - Swift Documentation](https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html)
- [iOS Human Interface Guidelines - Handling Errors](https://developer.apple.com/design/human-interface-guidelines/patterns/handling-errors/)
- [Swift Error Handling Best Practices](https://developer.apple.com/videos/play/wwdc2015/401/)
- [Async/Await Error Handling](https://developer.apple.com/videos/play/wwdc2021/10132/)