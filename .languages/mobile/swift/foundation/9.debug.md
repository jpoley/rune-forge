# Swift Mobile - Debugging & Diagnostics

## Xcode Debugging Tools

### Debug Navigator
```swift
// Debug-friendly code structure
import OSLog

class NetworkManager {
    private let logger = Logger(subsystem: "com.myapp.network", category: "requests")
    
    func fetchData(from url: URL) async throws -> Data {
        logger.debug("üåê Starting request to \(url.absoluteString)")
        
        let startTime = CFAbsoluteTimeGetCurrent()
        defer {
            let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
            logger.debug("‚è±Ô∏è Request completed in \(timeElapsed)s")
        }
        
        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            
            if let httpResponse = response as? HTTPURLResponse {
                logger.info("üì° Response: \(httpResponse.statusCode)")
                
                // Debug response details
                #if DEBUG
                if let responseString = String(data: data, encoding: .utf8) {
                    logger.debug("üìÑ Response body: \(responseString)")
                }
                #endif
            }
            
            return data
        } catch {
            logger.error("‚ùå Network error: \(error.localizedDescription)")
            throw error
        }
    }
}
```

### Breakpoints & LLDB
```swift
// Strategic breakpoint placement
class ViewModelDebugging {
    @Published var items: [Item] = []
    @Published var isLoading = false
    
    func loadItems() {
        isLoading = true
        
        // Breakpoint here: Check initial state
        print("üîç Starting to load items, current count: \(items.count)")
        
        Task {
            do {
                let newItems = try await itemService.fetchItems()
                
                // Breakpoint here: Inspect fetched data
                await MainActor.run {
                    self.items = newItems
                    self.isLoading = false
                    
                    // Breakpoint here: Verify state update
                    print("‚úÖ Loaded \(newItems.count) items")
                }
            } catch {
                // Breakpoint here: Debug error scenarios
                await MainActor.run {
                    self.isLoading = false
                    print("‚ùå Failed to load items: \(error)")
                }
            }
        }
    }
}

// LLDB Commands for iOS debugging
/*
# Print object description
po myObject

# Print variable value  
p myVariable

# Print view hierarchy
expr -l objc++ -O -- [UIViewController _printHierarchy]

# Print all properties of an object
po [myObject valueForKey:@"_allProperties"]

# Debug memory issues
memory read 0x123456789

# Print current thread info
thread info

# Print all threads
thread list

# Continue execution
continue

# Step over
next

# Step into
step

# Step out
finish

# Print backtrace
bt

# Print Swift variables with types
frame variable -T

# Check retain count (for debugging memory leaks)
po [myObject retainCount]
*/
```

## Debug Console & Logging

### Unified Logging System
```swift
import OSLog

// Logger categories for different app areas
extension Logger {
    private static let subsystem = Bundle.main.bundleIdentifier!
    
    static let ui = Logger(subsystem: subsystem, category: "ui")
    static let network = Logger(subsystem: subsystem, category: "network")
    static let database = Logger(subsystem: subsystem, category: "database")
    static let auth = Logger(subsystem: subsystem, category: "auth")
    static let performance = Logger(subsystem: subsystem, category: "performance")
}

// Usage throughout the app
class LoginViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        Logger.ui.info("üè† LoginViewController loaded")
    }
    
    @IBAction func loginTapped(_ sender: UIButton) {
        Logger.ui.debug("üîê Login button tapped")
        
        guard let email = emailTextField.text, !email.isEmpty else {
            Logger.ui.warning("‚ö†Ô∏è Email field is empty")
            showError("Please enter your email")
            return
        }
        
        performLogin(email: email)
    }
    
    private func performLogin(email: String) {
        Logger.auth.info("üöÄ Starting login for user: \(email, privacy: .private)")
        
        Task {
            do {
                let user = try await authService.login(email: email)
                Logger.auth.info("‚úÖ Login successful for user ID: \(user.id)")
                
                await MainActor.run {
                    navigateToMainApp()
                }
            } catch {
                Logger.auth.error("‚ùå Login failed: \(error.localizedDescription)")
                
                await MainActor.run {
                    showError("Login failed: \(error.localizedDescription)")
                }
            }
        }
    }
}

// Performance monitoring
class PerformanceMonitor {
    static func measureTime<T>(_ operation: () async throws -> T, 
                              operation name: String) async rethrows -> T {
        let startTime = CFAbsoluteTimeGetCurrent()
        defer {
            let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
            Logger.performance.info("‚è±Ô∏è \(name) took \(timeElapsed)s")
        }
        
        return try await operation()
    }
}

// Usage
let result = await PerformanceMonitor.measureTime({
    try await heavyDataProcessing()
}, operation: "Data processing")
```

### Console Debugging Techniques
```swift
// Debug print with context
func debugPrint(_ message: Any, 
                file: String = #file, 
                function: String = #function, 
                line: Int = #line) {
    #if DEBUG
    let fileName = URL(fileURLWithPath: file).lastPathComponent
    print("üêõ [\(fileName):\(line)] \(function): \(message)")
    #endif
}

// Conditional debug prints
func conditionalDebug<T>(_ value: T, condition: Bool = true) {
    #if DEBUG
    if condition {
        debugPrint("Value: \(value)")
    }
    #endif
}

// Debug only code blocks
#if DEBUG
class DebugHelper {
    static func injectTestData() {
        // Test data injection for debugging
    }
    
    static func simulateNetworkDelay() async {
        try? await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
    }
}
#endif

// Usage in ViewDidLoad
override func viewDidLoad() {
    super.viewDidLoad()
    
    #if DEBUG
    DebugHelper.injectTestData()
    #endif
}
```

## Memory Debugging

### Instruments Integration
```swift
// Memory-efficient coding patterns
class MemoryEfficientImageCache {
    private let cache = NSCache<NSString, UIImage>()
    private let logger = Logger(subsystem: "com.myapp.cache", category: "memory")
    
    init() {
        // Configure cache limits
        cache.countLimit = 50
        cache.totalCostLimit = 50 * 1024 * 1024 // 50MB
        
        // Monitor memory warnings
        NotificationCenter.default.addObserver(
            forName: UIApplication.didReceiveMemoryWarningNotification,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.handleMemoryWarning()
        }
        
        logger.info("üß† ImageCache initialized with limits: \(cache.countLimit) items, \(cache.totalCostLimit / (1024*1024))MB")
    }
    
    deinit {
        logger.info("üóëÔ∏è ImageCache deallocated")
        NotificationCenter.default.removeObserver(self)
    }
    
    func setImage(_ image: UIImage, forKey key: String) {
        let cost = Int(image.size.width * image.size.height * 4) // Rough byte calculation
        cache.setObject(image, forKey: key as NSString, cost: cost)
        
        logger.debug("üíæ Cached image for key: \(key), cost: \(cost) bytes")
    }
    
    func image(forKey key: String) -> UIImage? {
        let image = cache.object(forKey: key as NSString)
        logger.debug("üîç Cache \(image != nil ? "hit" : "miss") for key: \(key)")
        return image
    }
    
    private func handleMemoryWarning() {
        logger.warning("‚ö†Ô∏è Memory warning received, clearing cache")
        cache.removeAllObjects()
    }
}

// Weak reference debugging
class WeakReferenceDebugger {
    weak var delegate: SomeDelegate?
    
    func performAction() {
        guard let delegate = delegate else {
            Logger.ui.warning("‚ö†Ô∏è Delegate is nil - possible memory leak or premature deallocation")
            return
        }
        
        delegate.performAction()
    }
}

// Memory leak detection patterns
class LeakDetectionHelper {
    private static var allocationCount = 0
    private static var deallocationCount = 0
    
    static func trackAllocation(for className: String) {
        allocationCount += 1
        Logger.performance.debug("‚ûï \(className) allocated (total: \(allocationCount))")
    }
    
    static func trackDeallocation(for className: String) {
        deallocationCount += 1
        Logger.performance.debug("‚ûñ \(className) deallocated (total: \(deallocationCount))")
    }
    
    static func printLeakReport() {
        let leakCount = allocationCount - deallocationCount
        if leakCount > 0 {
            Logger.performance.warning("üö® Potential memory leaks detected: \(leakCount) objects")
        } else {
            Logger.performance.info("‚úÖ No memory leaks detected")
        }
    }
}

// Usage in classes
class MyViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        LeakDetectionHelper.trackAllocation(for: "MyViewController")
    }
    
    deinit {
        LeakDetectionHelper.trackDeallocation(for: "MyViewController")
    }
}
```

## Network Debugging

### URL Session Debugging
```swift
class DebuggingURLSession {
    static let shared = DebuggingURLSession()
    
    private let session: URLSession
    private let logger = Logger(subsystem: "com.myapp.network", category: "debugging")
    
    init() {
        let configuration = URLSessionConfiguration.default
        
        #if DEBUG
        // Enable detailed logging in debug builds
        configuration.protocolClasses = [DebuggingURLProtocol.self]
        #endif
        
        session = URLSession(configuration: configuration)
    }
    
    func dataTask(with url: URL) async throws -> (Data, URLResponse) {
        logger.info("üåê Starting request: \(url.absoluteString)")
        
        let startTime = Date()
        
        do {
            let (data, response) = try await session.data(from: url)
            
            let duration = Date().timeIntervalSince(startTime)
            logger.info("‚úÖ Request completed in \(duration)s, received \(data.count) bytes")
            
            if let httpResponse = response as? HTTPURLResponse {
                logger.debug("üì° Status: \(httpResponse.statusCode)")
                logger.debug("üìã Headers: \(httpResponse.allHeaderFields)")
                
                #if DEBUG
                if let responseString = String(data: data, encoding: .utf8) {
                    logger.debug("üìÑ Response: \(responseString)")
                }
                #endif
            }
            
            return (data, response)
        } catch {
            let duration = Date().timeIntervalSince(startTime)
            logger.error("‚ùå Request failed after \(duration)s: \(error.localizedDescription)")
            throw error
        }
    }
}

// Custom URL Protocol for debugging
class DebuggingURLProtocol: URLProtocol {
    private static let logger = Logger(subsystem: "com.myapp.network", category: "protocol")
    
    override class func canInit(with request: URLRequest) -> Bool {
        true
    }
    
    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        request
    }
    
    override func startLoading() {
        guard let url = request.url else { return }
        
        Self.logger.debug("üîç Intercepted request: \(url.absoluteString)")
        Self.logger.debug("üîß Method: \(request.httpMethod ?? "GET")")
        
        if let headers = request.allHTTPHeaderFields {
            Self.logger.debug("üìã Headers: \(headers)")
        }
        
        if let body = request.httpBody, let bodyString = String(data: body, encoding: .utf8) {
            Self.logger.debug("üì¶ Body: \(bodyString)")
        }
        
        // Continue with normal request
        let task = URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            if let error = error {
                self?.client?.urlProtocol(self!, didFailWithError: error)
            } else if let response = response {
                self?.client?.urlProtocol(self!, didReceive: response, cacheStoragePolicy: .notAllowed)
                
                if let data = data {
                    self?.client?.urlProtocol(self!, didLoad: data)
                }
                
                self?.client?.urlProtocolDidFinishLoading(self!)
            }
        }
        
        task.resume()
    }
    
    override func stopLoading() {
        // Cleanup if needed
    }
}
```

## UI Debugging

### View Hierarchy Debugging
```swift
// UI debugging utilities
extension UIView {
    func debugViewHierarchy(level: Int = 0) {
        let indent = String(repeating: "  ", count: level)
        let description = "\(type(of: self))"
        let frame = "frame: \(self.frame)"
        let hidden = isHidden ? " [HIDDEN]" : ""
        let alpha = alpha < 1.0 ? " [Œ±:\(alpha)]" : ""
        
        print("\(indent)üîç \(description) \(frame)\(hidden)\(alpha)")
        
        for subview in subviews {
            subview.debugViewHierarchy(level: level + 1)
        }
    }
    
    func findSubview<T: UIView>(of type: T.Type) -> T? {
        if let view = self as? T {
            return view
        }
        
        for subview in subviews {
            if let found = subview.findSubview(of: type) {
                return found
            }
        }
        
        return nil
    }
    
    func highlightForDebugging(color: UIColor = .red, duration: TimeInterval = 2.0) {
        #if DEBUG
        let originalBackgroundColor = backgroundColor
        backgroundColor = color
        
        DispatchQueue.main.asyncAfter(deadline: .now() + duration) {
            self.backgroundColor = originalBackgroundColor
        }
        #endif
    }
}

// SwiftUI debugging
extension View {
    func debugPrint(_ value: Any) -> some View {
        #if DEBUG
        print("SwiftUI Debug: \(value)")
        #endif
        return self
    }
    
    func debugBackground(_ color: Color = .red) -> some View {
        #if DEBUG
        return self.background(color.opacity(0.3))
        #else
        return self
        #endif
    }
    
    func debugBorder(_ color: Color = .red, width: CGFloat = 1) -> some View {
        #if DEBUG
        return self.border(color, width: width)
        #else
        return self
        #endif
    }
}

// Usage examples
struct DebugView: View {
    @State private var text = ""
    
    var body: some View {
        VStack {
            TextField("Enter text", text: $text)
                .debugBorder(.blue)
                .debugPrint("TextField value: \(text)")
            
            Button("Submit") {
                print("Button tapped with text: \(text)")
            }
            .debugBackground(.green)
        }
        .padding()
        .debugBorder(.red)
    }
}
```

## Performance Debugging

### Time Profiler Integration
```swift
// Performance measurement utilities
class PerformanceProfiler {
    private static let logger = Logger(subsystem: "com.myapp.performance", category: "profiler")
    
    static func measure<T>(_ operation: () throws -> T, 
                          name: String) rethrows -> T {
        let startTime = CFAbsoluteTimeGetCurrent()
        let result = try operation()
        let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
        
        logger.info("‚è±Ô∏è \(name): \(timeElapsed * 1000)ms")
        
        // Send to analytics in production
        #if !DEBUG
        Analytics.track("performance_measure", properties: [
            "operation": name,
            "duration_ms": timeElapsed * 1000
        ])
        #endif
        
        return result
    }
    
    static func measureAsync<T>(_ operation: () async throws -> T, 
                               name: String) async rethrows -> T {
        let startTime = CFAbsoluteTimeGetCurrent()
        let result = try await operation()
        let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
        
        logger.info("‚è±Ô∏è \(name): \(timeElapsed * 1000)ms")
        
        return result
    }
}

// Usage in ViewControllers
class OptimizedViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
        PerformanceProfiler.measure({
            setupUI()
        }, name: "UI Setup")
        
        Task {
            await PerformanceProfiler.measureAsync({
                try await loadInitialData()
            }, name: "Initial Data Load")
        }
    }
    
    private func setupUI() {
        // UI setup code
    }
    
    private func loadInitialData() async throws {
        // Data loading code
    }
}

// Frame rate monitoring
class FrameRateMonitor {
    private var displayLink: CADisplayLink?
    private var lastTimestamp: CFTimeInterval = 0
    private var frameCount = 0
    private let logger = Logger(subsystem: "com.myapp.performance", category: "fps")
    
    func startMonitoring() {
        displayLink = CADisplayLink(target: self, selector: #selector(displayLinkTick))
        displayLink?.add(to: .main, forMode: .common)
    }
    
    func stopMonitoring() {
        displayLink?.invalidate()
        displayLink = nil
    }
    
    @objc private func displayLinkTick(_ link: CADisplayLink) {
        if lastTimestamp == 0 {
            lastTimestamp = link.timestamp
            return
        }
        
        frameCount += 1
        let elapsed = link.timestamp - lastTimestamp
        
        if elapsed >= 1.0 {
            let fps = Double(frameCount) / elapsed
            logger.info("üìä FPS: \(Int(fps))")
            
            if fps < 55 {
                logger.warning("‚ö†Ô∏è Low frame rate detected: \(Int(fps)) FPS")
            }
            
            frameCount = 0
            lastTimestamp = link.timestamp
        }
    }
}
```

## Crash Debugging

### Crash Reporting Integration
```swift
import CrashReporter // Example: Crashlytics, Bugsnag, etc.

class CrashReportingManager {
    private let logger = Logger(subsystem: "com.myapp.crash", category: "reporting")
    
    static let shared = CrashReportingManager()
    
    private init() {
        setupCrashReporting()
        setupUncaughtExceptionHandler()
    }
    
    private func setupCrashReporting() {
        // Initialize crash reporting service
        #if !DEBUG
        CrashReporter.configure()
        #endif
        
        logger.info("üîß Crash reporting configured")
    }
    
    private func setupUncaughtExceptionHandler() {
        NSSetUncaughtExceptionHandler { exception in
            let logger = Logger(subsystem: "com.myapp.crash", category: "exception")
            logger.critical("üí• Uncaught exception: \(exception.name.rawValue) - \(exception.reason ?? "")")
            logger.critical("üîç Stack trace: \(exception.callStackSymbols)")
            
            #if !DEBUG
            CrashReporter.recordException(exception)
            #endif
        }
    }
    
    func recordCustomError(_ error: Error, context: [String: Any] = [:]) {
        logger.error("üö® Custom error recorded: \(error.localizedDescription)")
        
        #if !DEBUG
        var contextWithDefaults = context
        contextWithDefaults["timestamp"] = ISO8601DateFormatter().string(from: Date())
        contextWithDefaults["app_version"] = Bundle.main.versionNumber
        contextWithDefaults["build_number"] = Bundle.main.buildNumber
        
        CrashReporter.recordError(error, context: contextWithDefaults)
        #endif
    }
    
    func addBreadcrumb(_ message: String, category: String = "general") {
        logger.debug("üçû Breadcrumb: [\(category)] \(message)")
        
        #if !DEBUG
        CrashReporter.addBreadcrumb(message: message, category: category)
        #endif
    }
}

// Usage throughout the app
extension UIViewController {
    func recordViewAppearance() {
        let viewControllerName = String(describing: type(of: self))
        CrashReportingManager.shared.addBreadcrumb(
            "Appeared: \(viewControllerName)",
            category: "navigation"
        )
    }
}

class NetworkService {
    func performRequest() async {
        CrashReportingManager.shared.addBreadcrumb(
            "Starting network request",
            category: "network"
        )
        
        do {
            let result = try await makeRequest()
            CrashReportingManager.shared.addBreadcrumb(
                "Network request succeeded",
                category: "network"
            )
        } catch {
            CrashReportingManager.shared.recordCustomError(error, context: [
                "operation": "network_request",
                "endpoint": "api/data"
            ])
        }
    }
}
```

## Testing & Debugging

### Debug-Friendly Test Code
```swift
import XCTest
@testable import MyApp

class DebuggingTests: XCTestCase {
    var networkService: NetworkService!
    
    override func setUp() {
        super.setUp()
        
        // Enable verbose logging for tests
        #if DEBUG
        UserDefaults.standard.set(true, forKey: "VerboseLogging")
        #endif
        
        networkService = NetworkService()
    }
    
    func testNetworkRequestWithDebugging() async {
        let expectation = XCTestExpectation(description: "Network request completes")
        
        do {
            let result = await PerformanceProfiler.measureAsync({
                try await networkService.fetchData()
            }, name: "Test Network Request")
            
            XCTAssertNotNil(result, "Result should not be nil")
            expectation.fulfill()
            
        } catch {
            XCTFail("Network request failed: \(error)")
        }
        
        await fulfillment(of: [expectation], timeout: 10.0)
    }
    
    func testMemoryLeakDebugging() {
        weak var weakViewController: UIViewController?
        
        autoreleasepool {
            let viewController = MyViewController()
            weakViewController = viewController
            
            // Simulate view lifecycle
            viewController.loadViewIfNeeded()
            viewController.viewDidLoad()
            viewController.viewWillAppear(false)
            viewController.viewDidAppear(false)
        }
        
        // Check for memory leaks
        XCTAssertNil(weakViewController, "ViewController should be deallocated")
    }
}

// UI testing with debugging
class UITestsWithDebugging: XCTestCase {
    var app: XCUIApplication!
    
    override func setUp() {
        super.setUp()
        continueAfterFailure = false
        
        app = XCUIApplication()
        
        // Enable debug logging for UI tests
        app.launchArguments = ["--uitesting"]
        app.launchEnvironment = ["VERBOSE_LOGGING": "1"]
        
        app.launch()
    }
    
    func testLoginFlowWithDebugging() {
        let emailField = app.textFields["Email"]
        let passwordField = app.secureTextFields["Password"]
        let loginButton = app.buttons["Login"]
        
        // Add debugging information
        print("üîç Email field exists: \(emailField.exists)")
        print("üîç Password field exists: \(passwordField.exists)")
        print("üîç Login button exists: \(loginButton.exists)")
        
        XCTAssertTrue(emailField.exists, "Email field should exist")
        XCTAssertTrue(passwordField.exists, "Password field should exist")
        XCTAssertTrue(loginButton.exists, "Login button should exist")
        
        emailField.tap()
        emailField.typeText("test@example.com")
        
        passwordField.tap()
        passwordField.typeText("password123")
        
        loginButton.tap()
        
        // Wait for navigation with debugging
        let homeTitle = app.navigationBars["Home"]
        let exists = homeTitle.waitForExistence(timeout: 5)
        
        if !exists {
            // Take screenshot for debugging
            let screenshot = XCUIScreen.main.screenshot()
            let attachment = XCTAttachment(screenshot: screenshot)
            attachment.name = "Login Flow Failed"
            add(attachment)
        }
        
        XCTAssertTrue(exists, "Should navigate to home screen")
    }
}
```

## Best Practices

### Debug Configuration Management
- Use build configurations to enable/disable debugging features
- Implement proper logging levels (debug, info, warning, error)
- Use privacy-aware logging for sensitive data
- Configure different log destinations for different environments
- Implement performance monitoring in production builds

### Memory Management
- Use weak references appropriately to avoid retain cycles
- Monitor memory usage with Instruments
- Implement proper cleanup in deinit methods
- Use autoreleasepool for memory-intensive operations
- Track object allocation/deallocation in debug builds

### Network Debugging
- Log all network requests and responses in debug builds
- Implement request/response interceptors for debugging
- Use Charles Proxy or similar tools for network analysis
- Monitor network performance and errors
- Implement proper error handling and logging

### UI Debugging
- Use view hierarchy debugging tools
- Implement debug overlays for layout debugging
- Add accessibility identifiers for UI testing
- Use performance monitoring for UI responsiveness
- Implement proper error states and loading indicators