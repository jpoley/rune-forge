# Swift-Specific Features for Mobile Development

## Overview

Swift includes unique language features that make iOS development more expressive, safe, and performant. These features distinguish Swift from other languages and provide powerful tools for building robust mobile applications.

## Property Wrappers

### Built-in Property Wrappers (SwiftUI)
```swift
struct UserProfileView: View {
    // State management
    @State private var username = ""
    @State private var isEditing = false
    @State private var showingAlert = false
    
    // Binding for two-way data flow
    @Binding var isPresented: Bool
    
    // Observable object for complex state
    @ObservedObject var viewModel: UserViewModel
    
    // Environment object for app-wide state
    @EnvironmentObject var userSession: UserSession
    
    // App storage for persistent data
    @AppStorage("isDarkMode") private var isDarkMode = false
    @AppStorage("username") private var savedUsername = ""
    
    // Scene storage for per-scene data
    @SceneStorage("selectedTab") private var selectedTab = 0
    
    // State object for owned observable objects
    @StateObject private var locationManager = LocationManager()
    
    var body: some View {
        VStack {
            TextField("Username", text: $username)
            
            Toggle("Dark Mode", isOn: $isDarkMode)
            
            if isEditing {
                Button("Save") {
                    viewModel.updateUsername(username)
                }
            }
        }
        .alert("Error", isPresented: $showingAlert) {
            Button("OK") { }
        }
    }
}
```

### Custom Property Wrappers for Mobile
```swift
// UserDefaults wrapper
@propertyWrapper
struct UserDefault<T> {
    let key: String
    let defaultValue: T
    
    var wrappedValue: T {
        get {
            UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
        }
        set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
}

// Keychain wrapper for secure storage
@propertyWrapper
struct Keychain {
    let key: String
    
    var wrappedValue: String? {
        get {
            KeychainHelper.shared.get(key)
        }
        set {
            if let value = newValue {
                KeychainHelper.shared.set(value, forKey: key)
            } else {
                KeychainHelper.shared.delete(key)
            }
        }
    }
}

// Validation wrapper
@propertyWrapper
struct Validated<T> {
    private var value: T
    private let validator: (T) -> Bool
    private let errorMessage: String
    
    var wrappedValue: T {
        get { value }
        set {
            if validator(newValue) {
                value = newValue
            } else {
                print("Validation failed: \(errorMessage)")
            }
        }
    }
    
    init(wrappedValue: T, validator: @escaping (T) -> Bool, errorMessage: String) {
        self.value = wrappedValue
        self.validator = validator
        self.errorMessage = errorMessage
    }
}

// Usage in model
struct User {
    @UserDefault(key: "theme", defaultValue: "system")
    var theme: String
    
    @Keychain(key: "authToken")
    var authToken: String?
    
    @Validated(validator: { $0.contains("@") }, errorMessage: "Invalid email")
    var email: String = ""
}
```

### Threading Property Wrapper
```swift
@propertyWrapper
struct MainActor<Value> {
    private var value: Value
    
    var wrappedValue: Value {
        get {
            dispatchPrecondition(condition: .onQueue(.main))
            return value
        }
        set {
            dispatchPrecondition(condition: .onQueue(.main))
            value = newValue
        }
    }
    
    init(wrappedValue: Value) {
        self.value = wrappedValue
    }
}

class ViewModel {
    @MainActor var isLoading = false
    @MainActor var errorMessage: String?
    
    func updateUI() {
        // These will assert if not called on main thread
        isLoading = false
        errorMessage = nil
    }
}
```

## Result Builders

### SwiftUI View Builder
```swift
// SwiftUI's built-in result builder
@ViewBuilder
func buildUserInterface(user: User) -> some View {
    VStack {
        Text(user.name)
            .font(.title)
        
        if user.hasProfileImage {
            AsyncImage(url: user.profileImageURL)
        }
        
        ForEach(user.badges) { badge in
            BadgeView(badge: badge)
        }
    }
}
```

### Custom Result Builders for Mobile
```swift
@resultBuilder
struct AttributedStringBuilder {
    static func buildBlock(_ components: NSAttributedString...) -> NSAttributedString {
        let result = NSMutableAttributedString()
        components.forEach { result.append($0) }
        return result
    }
    
    static func buildEither(first component: NSAttributedString) -> NSAttributedString {
        return component
    }
    
    static func buildEither(second component: NSAttributedString) -> NSAttributedString {
        return component
    }
    
    static func buildOptional(_ component: NSAttributedString?) -> NSAttributedString {
        return component ?? NSAttributedString()
    }
}

func buildAttributedText(@AttributedStringBuilder _ content: () -> NSAttributedString) -> NSAttributedString {
    return content()
}

// Usage
let welcomeText = buildAttributedText {
    NSAttributedString(string: "Welcome ", attributes: [.font: UIFont.systemFont(ofSize: 16)])
    NSAttributedString(string: user.name, attributes: [.font: UIFont.boldSystemFont(ofSize: 16), .foregroundColor: UIColor.blue])
    NSAttributedString(string: "!", attributes: [.font: UIFont.systemFont(ofSize: 16)])
}

// Navigation builder for programmatic navigation
@resultBuilder
struct NavigationBuilder {
    static func buildBlock(_ steps: NavigationStep...) -> [NavigationStep] {
        return steps
    }
    
    static func buildOptional(_ component: [NavigationStep]?) -> [NavigationStep] {
        return component ?? []
    }
    
    static func buildEither(first component: [NavigationStep]) -> [NavigationStep] {
        return component
    }
    
    static func buildEither(second component: [NavigationStep]) -> [NavigationStep] {
        return component
    }
}

struct NavigationStep {
    let viewController: UIViewController
    let animated: Bool
    let completion: (() -> Void)?
}

func performNavigation(@NavigationBuilder _ steps: () -> [NavigationStep]) {
    let navigationSteps = steps()
    // Execute navigation steps
}

// Usage
performNavigation {
    NavigationStep(viewController: ProfileViewController(), animated: true, completion: nil)
    
    if user.isPremium {
        NavigationStep(viewController: PremiumViewController(), animated: true, completion: nil)
    }
    
    NavigationStep(viewController: SettingsViewController(), animated: false, completion: {
        print("Navigation completed")
    })
}
```

## Opaque Return Types

### SwiftUI View Returns
```swift
// Opaque return type for SwiftUI views
struct ContentView: View {
    var body: some View {  // 'some View' is opaque return type
        VStack {
            headerView
            contentSection
            footerView
        }
    }
    
    private var headerView: some View {
        HStack {
            Text("My App")
                .font(.largeTitle)
            Spacer()
            Button("Settings") { }
        }
    }
    
    @ViewBuilder
    private var contentSection: some View {
        if dataLoaded {
            List(items) { item in
                ItemRow(item: item)
            }
        } else {
            ProgressView("Loading...")
        }
    }
    
    private var footerView: some View {
        Text("Â© 2024 My Company")
            .font(.caption)
            .foregroundColor(.secondary)
    }
}
```

### Generic Return Types with Constraints
```swift
protocol Drawable {
    func draw()
}

struct Circle: Drawable {
    func draw() { print("Drawing circle") }
}

struct Rectangle: Drawable {
    func draw() { print("Drawing rectangle") }
}

// Opaque return type hides concrete type but preserves type identity
func makeShape(isRound: Bool) -> some Drawable {
    if isRound {
        return Circle()
    } else {
        return Rectangle()
    }
}

// Usage
let shape = makeShape(isRound: true)
shape.draw()  // Type is preserved, can call methods

// Multiple return constraints
protocol Identifiable {
    var id: String { get }
}

protocol Displayable {
    var title: String { get }
}

func makeDisplayableItem() -> some Identifiable & Displayable {
    return DisplayItem(id: UUID().uuidString, title: "Sample Item")
}
```

## Phantom Types and Type Safety

### Compile-time State Tracking
```swift
enum LoggedIn {}
enum LoggedOut {}

struct APIClient<AuthState> {
    private let session: URLSession
    private let baseURL: URL
    
    private init(session: URLSession, baseURL: URL) {
        self.session = session
        self.baseURL = baseURL
    }
}

extension APIClient where AuthState == LoggedOut {
    static func create(baseURL: URL) -> APIClient<LoggedOut> {
        return APIClient<LoggedOut>(session: .shared, baseURL: baseURL)
    }
    
    func login(username: String, password: String) async throws -> APIClient<LoggedIn> {
        // Perform login
        let loginURL = baseURL.appendingPathComponent("/login")
        var request = URLRequest(url: loginURL)
        request.httpMethod = "POST"
        
        let (data, _) = try await session.data(for: request)
        let response = try JSONDecoder().decode(LoginResponse.self, from: data)
        
        // Create authenticated session
        let config = URLSessionConfiguration.default
        config.httpAdditionalHeaders = ["Authorization": "Bearer \(response.token)"]
        let authSession = URLSession(configuration: config)
        
        return APIClient<LoggedIn>(session: authSession, baseURL: baseURL)
    }
}

extension APIClient where AuthState == LoggedIn {
    func fetchUserProfile() async throws -> UserProfile {
        let url = baseURL.appendingPathComponent("/profile")
        let (data, _) = try await session.data(from: url)
        return try JSONDecoder().decode(UserProfile.self, from: data)
    }
    
    func updateProfile(_ profile: UserProfile) async throws {
        let url = baseURL.appendingPathComponent("/profile")
        var request = URLRequest(url: url)
        request.httpMethod = "PUT"
        request.httpBody = try JSONEncoder().encode(profile)
        
        _ = try await session.data(for: request)
    }
    
    func logout() -> APIClient<LoggedOut> {
        return APIClient<LoggedOut>.create(baseURL: baseURL)
    }
}

// Usage - compile-time safety
let client = APIClient<LoggedOut>.create(baseURL: URL(string: "https://api.example.com")!)
// client.fetchUserProfile()  // Compile error - not logged in

let loggedInClient = try await client.login(username: "user", password: "pass")
let profile = try await loggedInClient.fetchUserProfile()  // OK - authenticated
```

## Pattern Matching and Switch Expressions

### Advanced Enum Matching
```swift
enum AppState {
    case launching
    case authenticating(progress: Double)
    case authenticated(user: User)
    case backgrounded(lastActiveTime: Date)
    case terminated
}

enum NetworkState {
    case offline
    case connecting
    case connected(quality: ConnectionQuality)
    case error(NetworkError)
}

enum ConnectionQuality {
    case poor, fair, good, excellent
}

// Complex pattern matching
func handleAppState(_ appState: AppState, networkState: NetworkState) {
    switch (appState, networkState) {
    case (.launching, .offline):
        showOfflineMessage()
        
    case (.launching, .connecting):
        showConnectingIndicator()
        
    case (.authenticating(let progress), .connected(.good)), (.authenticating(let progress), .connected(.excellent)):
        showAuthProgress(progress)
        
    case (.authenticated(let user), .connected(let quality)) where quality != .poor:
        loadUserData(for: user, with: quality)
        
    case (.authenticated, .connected(.poor)):
        showLowQualityWarning()
        
    case (.backgrounded(let lastActive), _) where Date().timeIntervalSince(lastActive) > 300:
        requireReauthentication()
        
    case (_, .error(let error)):
        handleNetworkError(error)
        
    default:
        handleDefaultState(appState, networkState)
    }
}
```

### Value Binding and Guards
```swift
// Complex guard statements for iOS
func processUserData(_ data: [String: Any]) {
    guard let userID = data["id"] as? String,
          !userID.isEmpty,
          let name = data["name"] as? String,
          name.count >= 2,
          let email = data["email"] as? String,
          email.contains("@"),
          let ageNumber = data["age"] as? NSNumber,
          ageNumber.intValue >= 13  // iOS app age restriction
    else {
        showValidationError("Invalid user data")
        return
    }
    
    let user = User(id: userID, name: name, email: email, age: ageNumber.intValue)
    saveUser(user)
}

// Switch with complex binding
func handleNotification(_ notification: UNNotification) {
    let userInfo = notification.request.content.userInfo
    
    switch (userInfo["type"] as? String, userInfo["data"] as? [String: Any]) {
    case ("message", let data?) where data["sender_id"] != nil:
        handleMessageNotification(data: data)
        
    case ("like", let data?) where data["post_id"] is String:
        handleLikeNotification(data: data)
        
    case ("follow", let data?):
        handleFollowNotification(data: data)
        
    case (let type?, _):
        print("Unknown notification type: \(type)")
        
    default:
        handleGenericNotification()
    }
}
```

## Function Builders and DSL

### Custom DSL for UI Layout
```swift
@resultBuilder
struct LayoutBuilder {
    static func buildBlock(_ components: LayoutComponent...) -> [LayoutComponent] {
        return components
    }
    
    static func buildOptional(_ component: [LayoutComponent]?) -> [LayoutComponent] {
        return component ?? []
    }
    
    static func buildEither(first component: [LayoutComponent]) -> [LayoutComponent] {
        return component
    }
    
    static func buildEither(second component: [LayoutComponent]) -> [LayoutComponent] {
        return component
    }
}

struct LayoutComponent {
    let view: UIView
    let constraints: [NSLayoutConstraint]
}

func buildLayout(in containerView: UIView, @LayoutBuilder _ content: () -> [LayoutComponent]) {
    let components = content()
    
    components.forEach { component in
        containerView.addSubview(component.view)
        NSLayoutConstraint.activate(component.constraints)
    }
}

// Usage
buildLayout(in: view) {
    LayoutComponent(
        view: titleLabel,
        constraints: [
            titleLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 16),
            titleLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),
            titleLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16)
        ]
    )
    
    if showSubtitle {
        LayoutComponent(
            view: subtitleLabel,
            constraints: [
                subtitleLabel.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 8),
                subtitleLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),
                subtitleLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16)
            ]
        )
    }
    
    LayoutComponent(
        view: contentView,
        constraints: [
            contentView.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 24),
            contentView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            contentView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            contentView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
        ]
    )
}
```

## Dynamic Member Lookup

### JSON-like Data Access
```swift
@dynamicMemberLookup
struct DynamicJSON {
    private let data: [String: Any]
    
    init(_ data: [String: Any]) {
        self.data = data
    }
    
    subscript(dynamicMember member: String) -> DynamicJSON? {
        guard let value = data[member] else { return nil }
        
        if let dict = value as? [String: Any] {
            return DynamicJSON(dict)
        }
        
        // Wrap primitives in dictionary for consistent interface
        return DynamicJSON(["value": value])
    }
    
    var string: String? {
        return data["value"] as? String
    }
    
    var int: Int? {
        return data["value"] as? Int
    }
    
    var double: Double? {
        return data["value"] as? Double
    }
    
    var array: [DynamicJSON]? {
        guard let arr = data["value"] as? [[String: Any]] else { return nil }
        return arr.map { DynamicJSON($0) }
    }
}

// Usage
let jsonData = [
    "user": [
        "name": "John Doe",
        "age": 30,
        "address": [
            "street": "123 Main St",
            "city": "San Francisco"
        ],
        "posts": [
            ["id": 1, "title": "First Post"],
            ["id": 2, "title": "Second Post"]
        ]
    ]
]

let json = DynamicJSON(jsonData)
let userName = json.user?.name?.string  // "John Doe"
let userAge = json.user?.age?.int  // 30
let city = json.user?.address?.city?.string  // "San Francisco"
let posts = json.user?.posts?.array  // Array of DynamicJSON
```

### Type-safe API Client
```swift
@dynamicMemberLookup
struct APIEndpoint {
    let path: String
    
    subscript(dynamicMember member: String) -> APIEndpoint {
        return APIEndpoint(path: "\(path)/\(member)")
    }
    
    func get<T: Codable>(_ type: T.Type) async throws -> T {
        let url = URL(string: "https://api.example.com\(path)")!
        let (data, _) = try await URLSession.shared.data(from: url)
        return try JSONDecoder().decode(type, from: data)
    }
    
    func post<T: Codable, U: Codable>(_ body: T, returning type: U.Type) async throws -> U {
        let url = URL(string: "https://api.example.com\(path)")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.httpBody = try JSONEncoder().encode(body)
        
        let (data, _) = try await URLSession.shared.data(for: request)
        return try JSONDecoder().decode(type, from: data)
    }
}

let api = APIEndpoint(path: "")

// Type-safe API calls with dynamic syntax
let users = try await api.users.get([User].self)
let user = try await api.users.id("123").get(User.self)
let newPost = try await api.users.id("123").posts.post(postData, returning: Post.self)
```

## Key Path Expressions

### Functional Programming with Key Paths
```swift
struct User {
    let id: String
    let name: String
    let email: String
    let age: Int
    let isActive: Bool
}

let users: [User] = [
    User(id: "1", name: "Alice", email: "alice@example.com", age: 25, isActive: true),
    User(id: "2", name: "Bob", email: "bob@example.com", age: 30, isActive: false),
    User(id: "3", name: "Charlie", email: "charlie@example.com", age: 35, isActive: true)
]

// Using key paths for sorting and filtering
let sortedByName = users.sorted { $0[keyPath: \.name] < $1[keyPath: \.name] }
let sortedByAge = users.sorted { $0[keyPath: \.age] < $1[keyPath: \.age] }
let activeUsers = users.filter { $0[keyPath: \.isActive] }

// Key path utilities
extension Array {
    func sorted<T: Comparable>(by keyPath: KeyPath<Element, T>) -> [Element] {
        return sorted { $0[keyPath: keyPath] < $1[keyPath: keyPath] }
    }
    
    func max<T: Comparable>(by keyPath: KeyPath<Element, T>) -> Element? {
        return self.max { $0[keyPath: keyPath] < $1[keyPath: keyPath] }
    }
    
    func grouping<T: Hashable>(by keyPath: KeyPath<Element, T>) -> [T: [Element]] {
        return Dictionary(grouping: self) { $0[keyPath: keyPath] }
    }
}

// Usage
let oldestUser = users.max(by: \.age)
let usersByActiveStatus = users.grouping(by: \.isActive)
let namesSorted = users.sorted(by: \.name)
```

### Key Path Binding for UI
```swift
class FormField<Root, Value>: ObservableObject {
    private let root: Root
    private let keyPath: WritableKeyPath<Root, Value>
    
    init(_ root: Root, keyPath: WritableKeyPath<Root, Value>) {
        self.root = root
        self.keyPath = keyPath
    }
    
    var value: Value {
        get { root[keyPath: keyPath] }
        set { 
            root[keyPath: keyPath] = newValue
            objectWillChange.send()
        }
    }
}

class UserFormViewModel: ObservableObject {
    @Published var user = User(id: "", name: "", email: "", age: 0, isActive: true)
    
    lazy var nameField = FormField(user, keyPath: \.name)
    lazy var emailField = FormField(user, keyPath: \.email)
    lazy var ageField = FormField(user, keyPath: \.age)
}

// SwiftUI usage
struct UserFormView: View {
    @StateObject private var viewModel = UserFormViewModel()
    
    var body: some View {
        Form {
            TextField("Name", text: Binding(
                get: { viewModel.user.name },
                set: { viewModel.user.name = $0 }
            ))
            
            TextField("Email", text: Binding(
                get: { viewModel.user.email },
                set: { viewModel.user.email = $0 }
            ))
        }
    }
}
```

## Callable Types

### Function-like Objects
```swift
struct Multiplier {
    let factor: Int
    
    func callAsFunction(_ value: Int) -> Int {
        return value * factor
    }
    
    func callAsFunction(_ values: [Int]) -> [Int] {
        return values.map { $0 * factor }
    }
}

let double = Multiplier(factor: 2)
let triple = Multiplier(factor: 3)

let doubled = double(5)  // 10
let tripled = triple([1, 2, 3, 4])  // [3, 6, 9, 12]

// Validator as callable
struct EmailValidator {
    let pattern = #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"#
    
    func callAsFunction(_ email: String) -> Bool {
        return email.range(of: pattern, options: .regularExpression) != nil
    }
}

let isValidEmail = EmailValidator()
let valid = isValidEmail("user@example.com")  // true
let invalid = isValidEmail("invalid-email")   // false

// API Client as callable
struct APIClient {
    let baseURL: URL
    
    func callAsFunction<T: Codable>(
        _ endpoint: String,
        method: HTTPMethod = .GET,
        returning type: T.Type
    ) async throws -> T {
        let url = baseURL.appendingPathComponent(endpoint)
        var request = URLRequest(url: url)
        request.httpMethod = method.rawValue
        
        let (data, _) = try await URLSession.shared.data(for: request)
        return try JSONDecoder().decode(type, from: data)
    }
}

let api = APIClient(baseURL: URL(string: "https://api.example.com")!)
let users: [User] = try await api("/users", returning: [User].self)
```

## Advanced String Features

### String Interpolation
```swift
extension String.StringInterpolation {
    mutating func appendInterpolation<T: Numeric>(_ value: T, format: String) {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.positiveFormat = format
        
        if let result = formatter.string(from: NSNumber(value: value.doubleValue)) {
            appendLiteral(result)
        }
    }
    
    mutating func appendInterpolation(_ date: Date, style: DateFormatter.Style) {
        let formatter = DateFormatter()
        formatter.dateStyle = style
        appendLiteral(formatter.string(from: date))
    }
    
    mutating func appendInterpolation(if condition: Bool, _ text: String) {
        if condition {
            appendLiteral(text)
        }
    }
    
    mutating func appendInterpolation<T>(_ optional: T?, default defaultValue: String) {
        if let value = optional {
            appendInterpolation(value)
        } else {
            appendLiteral(defaultValue)
        }
    }
}

// Usage
let price = 1234.56
let message = "Price: \(price, format: "$#,##0.00")"  // "Price: $1,234.56"

let date = Date()
let dateString = "Today is \(date, style: .medium)"  // "Today is Jan 15, 2024"

let isPremium = true
let greeting = "Welcome\(if: isPremium, " Premium User")!"  // "Welcome Premium User!"

let username: String? = nil
let display = "User: \(username, default: "Guest")"  // "User: Guest"
```

### Raw Strings and Multi-line Literals
```swift
// Raw strings for regex patterns
let emailPattern = #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"#
let phonePattern = #"^\+?1?-?\.?\s?\(?(\d{3})\)?[-\.\s]?(\d{3})[-\.\s]?(\d{4})$"#

// Multi-line strings for JSON templates
let jsonTemplate = """
{
    "user": {
        "id": "\(userID)",
        "name": "\(userName)",
        "preferences": {
            "theme": "\(theme)",
            "notifications": \(notificationsEnabled ? "true" : "false")
        }
    }
}
"""

// Multi-line raw strings for complex patterns
let complexRegex = #"""
    (?x)                    # Enable verbose mode
    ^                       # Start of string
    (?=.*[a-z])            # At least one lowercase letter
    (?=.*[A-Z])            # At least one uppercase letter
    (?=.*\d)               # At least one digit
    (?=.*[!@#$%^&*])       # At least one special character
    .{8,}                  # At least 8 characters
    $                      # End of string
"""#

// Usage in iOS password validation
func isValidPassword(_ password: String) -> Bool {
    return password.range(of: complexRegex, options: .regularExpression) != nil
}
```

## Memory and Performance Features

### Copy-on-Write Collections
```swift
struct CopyOnWriteArray<T> {
    private var storage: Storage
    
    init() {
        storage = Storage()
    }
    
    private final class Storage {
        var elements: [T] = []
    }
    
    private mutating func ensureUniqueStorage() {
        if !isKnownUniquelyReferenced(&storage) {
            storage = Storage()
            storage.elements = storage.elements
        }
    }
    
    var count: Int {
        return storage.elements.count
    }
    
    subscript(index: Int) -> T {
        get {
            return storage.elements[index]
        }
        set {
            ensureUniqueStorage()
            storage.elements[index] = newValue
        }
    }
    
    mutating func append(_ element: T) {
        ensureUniqueStorage()
        storage.elements.append(element)
    }
}
```

### Unsafe Swift for Performance
```swift
// High-performance image processing
extension UIImage {
    func processedImage() -> UIImage? {
        guard let cgImage = self.cgImage else { return nil }
        
        let width = cgImage.width
        let height = cgImage.height
        let bytesPerPixel = 4
        let bytesPerRow = width * bytesPerPixel
        let bitsPerComponent = 8
        
        // Allocate memory for image data
        let imageData = UnsafeMutablePointer<UInt8>.allocate(capacity: width * height * bytesPerPixel)
        defer { imageData.deallocate() }
        
        // Create context and draw image
        guard let context = CGContext(
            data: imageData,
            width: width,
            height: height,
            bitsPerComponent: bitsPerComponent,
            bytesPerRow: bytesPerRow,
            space: CGColorSpaceCreateDeviceRGB(),
            bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
        ) else { return nil }
        
        context.draw(cgImage, in: CGRect(x: 0, y: 0, width: width, height: height))
        
        // Process pixels directly
        for y in 0..<height {
            for x in 0..<width {
                let pixelIndex = (y * width + x) * bytesPerPixel
                let red = imageData[pixelIndex]
                let green = imageData[pixelIndex + 1]
                let blue = imageData[pixelIndex + 2]
                let alpha = imageData[pixelIndex + 3]
                
                // Apply processing (e.g., grayscale)
                let gray = UInt8(0.299 * Double(red) + 0.587 * Double(green) + 0.114 * Double(blue))
                imageData[pixelIndex] = gray
                imageData[pixelIndex + 1] = gray
                imageData[pixelIndex + 2] = gray
                imageData[pixelIndex + 3] = alpha
            }
        }
        
        // Create new image from processed data
        guard let processedCGImage = context.makeImage() else { return nil }
        return UIImage(cgImage: processedCGImage)
    }
}
```

## Platform Integration Features

### Objective-C Interoperability
```swift
// Exposing Swift classes to Objective-C
@objc class SwiftViewController: UIViewController {
    @objc dynamic var title: String = ""
    
    @objc func updateTitle(_ newTitle: String) {
        title = newTitle
    }
    
    // Selector-based actions
    @objc private func buttonTapped(_ sender: UIButton) {
        // Handle tap
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let button = UIButton(type: .system)
        button.addTarget(self, action: #selector(buttonTapped(_:)), for: .touchUpInside)
    }
}

// Protocol for Objective-C compatibility
@objc protocol SwiftDelegate: AnyObject {
    @objc func didReceiveData(_ data: Data)
    @objc optional func willStartLoading()
    @objc optional func didFinishLoading()
}

// Enum for Objective-C (backed by Int)
@objc enum NetworkState: Int, CaseIterable {
    case disconnected = 0
    case connecting = 1
    case connected = 2
    case error = 3
    
    var displayName: String {
        switch self {
        case .disconnected: return "Disconnected"
        case .connecting: return "Connecting"
        case .connected: return "Connected"
        case .error: return "Error"
        }
    }
}
```

### C Interoperability
```swift
import Darwin

// Working with C APIs
func getCurrentTime() -> String {
    var currentTime = time_t()
    time(&currentTime)
    
    let timeString = ctime(&currentTime)
    return String(cString: timeString!).trimmingCharacters(in: .whitespacesAndNewlines)
}

// Memory management with C types
func processImageData(_ data: UnsafePointer<UInt8>, length: Int) -> [UInt8] {
    let buffer = UnsafeMutableBufferPointer<UInt8>.allocate(capacity: length)
    defer { buffer.deallocate() }
    
    // Copy and process data
    buffer.initialize(from: UnsafeBufferPointer(start: data, count: length))
    
    // Apply processing
    for i in 0..<length {
        buffer[i] = min(255, buffer[i] + 10)  // Brighten
    }
    
    return Array(buffer)
}
```

## References
- [Swift Language Guide - Advanced Operators](https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html)
- [Property Wrappers Proposal](https://github.com/apple/swift-evolution/blob/main/proposals/0258-property-wrappers.md)
- [Result Builders](https://github.com/apple/swift-evolution/blob/main/proposals/0289-result-builders.md)
- [Opaque Return Types](https://github.com/apple/swift-evolution/blob/main/proposals/0244-opaque-result-types.md)
- [Dynamic Member Lookup](https://github.com/apple/swift-evolution/blob/main/proposals/0195-dynamic-member-lookup.md)