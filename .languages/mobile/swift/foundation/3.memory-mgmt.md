# Swift Memory Management for Mobile Development

## Overview

Swift uses Automatic Reference Counting (ARC) to manage memory automatically, which is crucial for mobile apps where memory is constrained. Understanding ARC and memory patterns helps prevent crashes, improve performance, and provide smooth user experiences on iOS devices.

## Automatic Reference Counting (ARC)

### How ARC Works
```swift
// Reference counting example
class User {
    let name: String
    
    init(name: String) {
        self.name = name
        print("User \(name) is being initialized")
    }
    
    deinit {
        print("User \(name) is being deinitialized")
    }
}

func demonstrateARC() {
    var user1: User? = User(name: "Alice")    // Reference count: 1
    var user2 = user1                         // Reference count: 2
    
    user1 = nil                               // Reference count: 1
    user2 = nil                               // Reference count: 0 - object deallocated
}
```

### ARC and Classes vs Structs
```swift
// Classes are reference types (managed by ARC)
class UserProfile {
    let name: String
    var avatar: UIImage?
    
    init(name: String) {
        self.name = name
    }
    
    deinit {
        print("UserProfile for \(name) deallocated")
    }
}

// Structs are value types (copied, not reference counted)
struct UserSettings {
    var darkModeEnabled: Bool
    var notificationsEnabled: Bool
    var preferredLanguage: String
}

// Value types don't need memory management
func demonstrateValueTypes() {
    var settings1 = UserSettings(darkModeEnabled: true, notificationsEnabled: true, preferredLanguage: "en")
    var settings2 = settings1  // This creates a copy, not a reference
    
    settings2.darkModeEnabled = false  // Only affects settings2
    print("Settings1 dark mode: \(settings1.darkModeEnabled)")  // true
    print("Settings2 dark mode: \(settings2.darkModeEnabled)")  // false
}
```

## Strong References

### Default Reference Behavior
```swift
class ViewController: UIViewController {
    private let networkManager = NetworkManager()  // Strong reference
    private var userProfile: UserProfile?          // Strong reference (when assigned)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Strong reference created
        userProfile = UserProfile(name: "John")
        
        // ViewController holds strong reference to networkManager
        // networkManager will live as long as ViewController exists
    }
}
```

### Strong Reference Collections
```swift
class UserManager {
    private var activeUsers: [User] = []           // Array holds strong references
    private var userCache: [String: User] = [:]    // Dictionary holds strong references
    
    func addUser(_ user: User) {
        activeUsers.append(user)      // Strong reference added
        userCache[user.id] = user     // Another strong reference
    }
    
    func removeUser(_ user: User) {
        activeUsers.removeAll { $0.id == user.id }  // Remove strong reference
        userCache.removeValue(forKey: user.id)      // Remove strong reference
        // User will be deallocated if no other strong references exist
    }
}
```

## Weak References

### Preventing Retain Cycles
```swift
// Delegate pattern with weak reference
protocol ViewControllerDelegate: AnyObject {
    func didCompleteTask()
}

class TaskViewController: UIViewController {
    weak var delegate: ViewControllerDelegate?  // Weak to prevent retain cycle
    
    @IBAction func completeButtonTapped() {
        delegate?.didCompleteTask()
    }
}

class MainViewController: UIViewController, ViewControllerDelegate {
    func showTaskViewController() {
        let taskVC = TaskViewController()
        taskVC.delegate = self  // MainVC strongly holds taskVC, taskVC weakly holds MainVC
        navigationController?.pushViewController(taskVC, animated: true)
    }
    
    func didCompleteTask() {
        navigationController?.popViewController(animated: true)
    }
}
```

### Weak References in Closures
```swift
class ImageDownloader {
    private var completion: ((UIImage?) -> Void)?
    
    func downloadImage(from url: URL, completion: @escaping (UIImage?) -> Void) {
        self.completion = completion
        
        URLSession.shared.dataTask(with: url) { [weak self] data, _, error in
            DispatchQueue.main.async {
                guard let self = self else { return }  // Self might be deallocated
                
                if let data = data, let image = UIImage(data: data) {
                    self.completion?(image)
                } else {
                    self.completion?(nil)
                }
                
                self.completion = nil  // Clear completion to break potential cycles
            }
        }.resume()
    }
}
```

### Weak Reference Collections
```swift
class NotificationCenter {
    private var observers: [WeakObserver] = []
    
    func addObserver(_ observer: AnyObject, selector: Selector, name: String) {
        // Store weak reference to prevent retain cycles
        observers.append(WeakObserver(object: observer, selector: selector, name: name))
        cleanupDeallocatedObservers()
    }
    
    private func cleanupDeallocatedObservers() {
        observers = observers.filter { $0.object != nil }
    }
}

struct WeakObserver {
    weak var object: AnyObject?
    let selector: Selector
    let name: String
}

// NSHashTable for weak references collection
class WeakObjectSet<T: AnyObject> {
    private let hashTable = NSHashTable<T>.weakObjects()
    
    func add(_ object: T) {
        hashTable.add(object)
    }
    
    func remove(_ object: T) {
        hashTable.remove(object)
    }
    
    var allObjects: [T] {
        return hashTable.allObjects
    }
}
```

## Unowned References

### When to Use Unowned
```swift
class Customer {
    let name: String
    var card: CreditCard?
    
    init(name: String) {
        self.name = name
    }
    
    deinit {
        print("Customer \(name) is being deinitialized")
    }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer  // Unowned because card can't exist without customer
    
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    
    deinit {
        print("Card #\(number) is being deinitialized")
    }
}

// Usage - both objects have same lifetime
let john = Customer(name: "John Smith")
john.card = CreditCard(number: 1234_5678_9012_3456, customer: john)
// When john is deallocated, card is also deallocated
```

### Unowned vs Weak Decision Guide
```swift
// Use WEAK when:
// - The reference might become nil during the object's lifetime
// - Optional relationships
protocol DataSourceDelegate: AnyObject {
    func didUpdateData()
}

class DataSource {
    weak var delegate: DataSourceDelegate?  // Delegate might be nil
}

// Use UNOWNED when:
// - The reference should never be nil during the object's lifetime
// - The referenced object has equal or longer lifetime
class View {
    unowned let controller: UIViewController  // View can't exist without controller
    
    init(controller: UIViewController) {
        self.controller = controller
    }
}
```

## Retain Cycles and Solutions

### Common Retain Cycle Scenarios
```swift
// BAD: Retain cycle in closure
class ViewController: UIViewController {
    var completion: (() -> Void)?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // BAD: Creates retain cycle
        completion = {
            self.updateUI()  // Strong reference to self
        }
    }
}

// GOOD: Breaking retain cycle with weak self
class ViewController: UIViewController {
    var completion: (() -> Void)?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // GOOD: Weak capture breaks retain cycle
        completion = { [weak self] in
            self?.updateUI()
        }
    }
}
```

### Complex Retain Cycle Detection
```swift
// Parent-Child retain cycle
class Parent {
    var children: [Child] = []
    let name: String
    
    init(name: String) {
        self.name = name
    }
    
    func addChild(_ child: Child) {
        children.append(child)
        child.parent = self  // Creates retain cycle
    }
    
    deinit {
        print("Parent \(name) deallocated")
    }
}

class Child {
    weak var parent: Parent?  // SOLUTION: Make parent weak
    let name: String
    
    init(name: String) {
        self.name = name
    }
    
    deinit {
        print("Child \(name) deallocated")
    }
}
```

### Timer Retain Cycles
```swift
class TimerViewController: UIViewController {
    private var timer: Timer?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        startTimer()
    }
    
    // BAD: Creates retain cycle
    private func startTimerBad() {
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            self.updateDisplay()  // Timer strongly captures self
        }
    }
    
    // GOOD: Weak capture breaks retain cycle
    private func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.updateDisplay()
        }
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        timer?.invalidate()  // IMPORTANT: Always invalidate timers
        timer = nil
    }
    
    deinit {
        timer?.invalidate()  // Safety cleanup
        print("TimerViewController deallocated")
    }
}
```

## Memory Patterns for Mobile Performance

### Lazy Loading for Performance
```swift
class ExpensiveResource {
    private var _data: [String]?
    
    // Lazy computed property
    var data: [String] {
        if _data == nil {
            _data = loadExpensiveData()
        }
        return _data!
    }
    
    // Lazy stored property
    lazy var processor = DataProcessor()
    
    private func loadExpensiveData() -> [String] {
        // Simulate expensive operation
        return (1...1000).map { "Item \($0)" }
    }
}

// SwiftUI lazy loading
struct LazyImageView: View {
    let url: URL
    
    var body: some View {
        AsyncImage(url: url) { image in
            image
                .resizable()
                .aspectRatio(contentMode: .fit)
        } placeholder: {
            ProgressView()
        }
    }
}
```

### Memory-Efficient Collections
```swift
class EfficientDataManager {
    // Use NSCache for automatic memory management
    private let imageCache = NSCache<NSString, UIImage>()
    private let dataCache = NSCache<NSString, NSData>()
    
    init() {
        // Configure cache limits
        imageCache.totalCostLimit = 100 * 1024 * 1024  // 100MB
        imageCache.countLimit = 100  // Max 100 images
        
        // Respond to memory warnings
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(clearCaches),
            name: UIApplication.didReceiveMemoryWarningNotification,
            object: nil
        )
    }
    
    @objc private func clearCaches() {
        imageCache.removeAllObjects()
        dataCache.removeAllObjects()
    }
    
    // Weak references for temporary objects
    private let tempObjectsStorage = NSHashTable<AnyObject>.weakObjects()
    
    func addTemporaryObject(_ object: AnyObject) {
        tempObjectsStorage.add(object)
    }
}
```

### Copy-on-Write (COW) Optimization
```swift
struct LargeDataCollection {
    private var storage: Storage
    
    init() {
        storage = Storage()
    }
    
    // COW implementation
    private mutating func ensureUniqueStorage() {
        if !isKnownUniquelyReferenced(&storage) {
            storage = Storage(copying: storage)
        }
    }
    
    mutating func append(_ item: String) {
        ensureUniqueStorage()  // Copy only when modifying
        storage.items.append(item)
    }
    
    var items: [String] {
        return storage.items
    }
    
    private class Storage {
        var items: [String] = []
        
        init() {}
        
        init(copying other: Storage) {
            self.items = other.items
        }
    }
}
```

## Memory Debugging and Profiling

### Debug Memory Issues
```swift
class MemoryDebugger {
    #if DEBUG
    static func logMemoryUsage() {
        let memoryUsage = getMemoryUsage()
        print("Memory Usage: \(memoryUsage.used / 1024 / 1024)MB / \(memoryUsage.total / 1024 / 1024)MB")
    }
    
    private static func getMemoryUsage() -> (used: UInt64, total: UInt64) {
        var info = mach_task_basic_info()
        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
        
        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
                task_info(mach_task_self_,
                         task_flavor_t(MACH_TASK_BASIC_INFO),
                         $0,
                         &count)
            }
        }
        
        if kerr == KERN_SUCCESS {
            return (used: info.resident_size, total: info.virtual_size)
        } else {
            return (used: 0, total: 0)
        }
    }
    #endif
}

// Usage in development
#if DEBUG
class DebugViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Add debug button
        let debugButton = UIButton(type: .system)
        debugButton.setTitle("Memory Info", for: .normal)
        debugButton.addTarget(self, action: #selector(showMemoryInfo), for: .touchUpInside)
        
        view.addSubview(debugButton)
        // ... layout constraints
    }
    
    @objc private func showMemoryInfo() {
        MemoryDebugger.logMemoryUsage()
    }
}
#endif
```

### Leak Detection Patterns
```swift
class LeakDetector {
    private static var livingObjects: [String: Int] = [:]
    private static let queue = DispatchQueue(label: "leak-detector", attributes: .concurrent)
    
    static func trackAllocation(of type: String) {
        queue.async(flags: .barrier) {
            livingObjects[type, default: 0] += 1
        }
    }
    
    static func trackDeallocation(of type: String) {
        queue.async(flags: .barrier) {
            livingObjects[type, default: 0] -= 1
        }
    }
    
    static func reportLeaks() {
        queue.async {
            let leaks = livingObjects.filter { $0.value > 0 }
            if !leaks.isEmpty {
                print("Potential leaks detected:")
                for (type, count) in leaks {
                    print("  \(type): \(count) instances")
                }
            }
        }
    }
}

// Usage in classes
class TrackedViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        LeakDetector.trackAllocation(of: String(describing: type(of: self)))
    }
    
    deinit {
        LeakDetector.trackDeallocation(of: String(describing: type(of: self)))
    }
}
```

## SwiftUI Memory Management

### State Management and Memory
```swift
// ObservableObject for shared state
class UserViewModel: ObservableObject {
    @Published var user: User?
    @Published var isLoading = false
    
    private var cancellables = Set<AnyCancellable>()
    
    func loadUser() {
        isLoading = true
        
        userService.fetchCurrentUser()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] _ in
                    self?.isLoading = false
                },
                receiveValue: { [weak self] user in
                    self?.user = user
                }
            )
            .store(in: &cancellables)
    }
}

struct UserProfileView: View {
    @StateObject private var viewModel = UserViewModel()  // Strong reference
    
    var body: some View {
        Group {
            if viewModel.isLoading {
                ProgressView()
            } else if let user = viewModel.user {
                UserDetailView(user: user)
            }
        }
        .onAppear {
            viewModel.loadUser()
        }
    }
}

struct UserDetailView: View {
    let user: User  // Value type, no memory management needed
    
    var body: some View {
        VStack {
            Text(user.name)
            Text(user.email)
        }
    }
}
```

### Environment Objects and Memory
```swift
class AppState: ObservableObject {
    @Published var currentUser: User?
    @Published var isAuthenticated = false
    
    // Weak references for delegates/observers
    private weak var delegate: AppStateDelegate?
    
    func signIn(user: User) {
        currentUser = user
        isAuthenticated = true
        delegate?.didSignIn(user)
    }
    
    func signOut() {
        currentUser = nil
        isAuthenticated = false
        delegate?.didSignOut()
    }
}

@main
struct MyApp: App {
    @StateObject private var appState = AppState()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appState)  // Shared across view hierarchy
        }
    }
}
```

## Performance Optimization Patterns

### Object Pooling for Mobile
```swift
class ViewControllerPool<T: UIViewController> {
    private var pool: [T] = []
    private let createViewController: () -> T
    private let resetViewController: (T) -> Void
    private let maxPoolSize: Int
    
    init(
        maxPoolSize: Int = 5,
        createViewController: @escaping () -> T,
        resetViewController: @escaping (T) -> Void = { _ in }
    ) {
        self.maxPoolSize = maxPoolSize
        self.createViewController = createViewController
        self.resetViewController = resetViewController
    }
    
    func getViewController() -> T {
        if let viewController = pool.popLast() {
            return viewController
        } else {
            return createViewController()
        }
    }
    
    func returnViewController(_ viewController: T) {
        guard pool.count < maxPoolSize else { return }
        
        resetViewController(viewController)
        pool.append(viewController)
    }
}

// Usage
let detailVCPool = ViewControllerPool<DetailViewController>(
    maxPoolSize: 3,
    createViewController: { DetailViewController() },
    resetViewController: { vc in
        vc.reset()  // Clear data, reset state
    }
)
```

### Image Memory Management
```swift
class ImageMemoryManager {
    private let cache = NSCache<NSString, UIImage>()
    private let processingQueue = DispatchQueue(label: "image-processing", qos: .utility)
    
    init() {
        cache.totalCostLimit = 50 * 1024 * 1024  // 50MB
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(clearCache),
            name: UIApplication.didReceiveMemoryWarningNotification,
            object: nil
        )
    }
    
    func loadImage(from url: URL, size: CGSize? = nil) async -> UIImage? {
        let key = cacheKey(for: url, size: size)
        
        // Check cache first
        if let cachedImage = cache.object(forKey: key) {
            return cachedImage
        }
        
        // Load and process image off main thread
        return await withCheckedContinuation { continuation in
            processingQueue.async {
                guard let data = try? Data(contentsOf: url),
                      let image = UIImage(data: data) else {
                    continuation.resume(returning: nil)
                    return
                }
                
                let processedImage: UIImage
                if let targetSize = size {
                    processedImage = self.resizeImage(image, to: targetSize)
                } else {
                    processedImage = image
                }
                
                // Cache the processed image
                let cost = Int(targetSize?.width ?? image.size.width) * Int(targetSize?.height ?? image.size.height) * 4
                self.cache.setObject(processedImage, forKey: key, cost: cost)
                
                continuation.resume(returning: processedImage)
            }
        }
    }
    
    private func cacheKey(for url: URL, size: CGSize?) -> NSString {
        if let size = size {
            return "\(url.absoluteString)-\(size.width)x\(size.height)" as NSString
        } else {
            return url.absoluteString as NSString
        }
    }
    
    private func resizeImage(_ image: UIImage, to size: CGSize) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
        defer { UIGraphicsEndImageContext() }
        
        image.draw(in: CGRect(origin: .zero, size: size))
        return UIGraphicsGetImageFromCurrentImageContext() ?? image
    }
    
    @objc private func clearCache() {
        cache.removeAllObjects()
    }
}
```

## Memory Best Practices for iOS

### App Launch Optimization
```swift
class AppLauncher {
    static func optimizeForLaunch() {
        // Delay heavy initialization
        DispatchQueue.main.async {
            self.performEssentialSetup()
        }
        
        DispatchQueue.global(qos: .utility).async {
            self.performNonEssentialSetup()
        }
    }
    
    private static func performEssentialSetup() {
        // Only what's needed for first screen
    }
    
    private static func performNonEssentialSetup() {
        // Everything else
    }
}

@main
struct MyApp: App {
    init() {
        AppLauncher.optimizeForLaunch()
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

### Background Memory Management
```swift
class BackgroundMemoryManager {
    static func handleBackgroundTransition() {
        // Clear unnecessary data when app goes to background
        ImageCache.shared.reduceMemoryUsage()
        DatabaseManager.shared.clearTemporaryData()
        NetworkManager.shared.cancelNonEssentialRequests()
    }
    
    static func handleForegroundTransition() {
        // Restore necessary data when app becomes active
        DatabaseManager.shared.refreshCriticalData()
    }
}

// In SceneDelegate or App
func sceneDidEnterBackground(_ scene: UIScene) {
    BackgroundMemoryManager.handleBackgroundTransition()
}

func sceneWillEnterForeground(_ scene: UIScene) {
    BackgroundMemoryManager.handleForegroundTransition()
}
```

## Memory Testing and Validation

### Unit Testing Memory Behavior
```swift
import XCTest

class MemoryTests: XCTestCase {
    func testViewControllerDeallocation() {
        weak var weakViewController: UIViewController?
        
        autoreleasepool {
            let viewController = TestViewController()
            weakViewController = viewController
            
            // Use the view controller
            _ = viewController.view  // Trigger viewDidLoad
        }
        
        // Give ARC time to clean up
        RunLoop.current.run(until: Date(timeIntervalSinceNow: 0.1))
        
        XCTAssertNil(weakViewController, "View controller should be deallocated")
    }
    
    func testRetainCyclePrevention() {
        weak var weakManager: NetworkManager?
        weak var weakViewController: UIViewController?
        
        autoreleasepool {
            let manager = NetworkManager()
            let viewController = TestViewController()
            
            viewController.setNetworkManager(manager)
            
            weakManager = manager
            weakViewController = viewController
        }
        
        XCTAssertNil(weakManager, "NetworkManager should be deallocated")
        XCTAssertNil(weakViewController, "ViewController should be deallocated")
    }
}
```

## References
- [Automatic Reference Counting - Swift Documentation](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)
- [Memory Management in iOS](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html)
- [Using Instruments for Memory Analysis](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html)
- [iOS Memory Deep Dive - WWDC](https://developer.apple.com/videos/play/wwdc2018/416/)