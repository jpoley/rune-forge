# Swift Concurrency for Mobile Development

## Overview

Swift's concurrency model provides safe, efficient ways to handle asynchronous operations crucial for mobile apps - network requests, database operations, image processing, and UI updates. The modern async/await syntax (iOS 13+) and actors (iOS 15+) make concurrent code more readable and less error-prone than traditional callback-based approaches.

## Async/Await Fundamentals

### Basic Async Functions
```swift
// Simple async function
func fetchUserProfile(userID: String) async throws -> UserProfile {
    let url = URL(string: "https://api.example.com/users/\(userID)")!
    let (data, _) = try await URLSession.shared.data(from: url)
    return try JSONDecoder().decode(UserProfile.self, from: data)
}

// Using async function in UIKit
class ProfileViewController: UIViewController {
    @IBOutlet weak var profileImageView: UIImageView!
    @IBOutlet weak var nameLabel: UILabel!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        Task {
            await loadUserProfile()
        }
    }
    
    private func loadUserProfile() async {
        do {
            let profile = try await fetchUserProfile(userID: "123")
            
            // Update UI on main thread
            await MainActor.run {
                nameLabel.text = profile.name
                // Load profile image
                loadProfileImage(from: profile.avatarURL)
            }
        } catch {
            await MainActor.run {
                showError("Failed to load profile: \(error.localizedDescription)")
            }
        }
    }
}
```

### SwiftUI Async Integration
```swift
struct UserProfileView: View {
    let userID: String
    @State private var profile: UserProfile?
    @State private var isLoading = false
    @State private var errorMessage: String?
    
    var body: some View {
        Group {
            if isLoading {
                ProgressView("Loading profile...")
            } else if let profile = profile {
                ProfileContentView(profile: profile)
            } else if let errorMessage = errorMessage {
                ErrorView(message: errorMessage, retryAction: loadProfile)
            } else {
                Text("No profile data")
            }
        }
        .task {
            await loadProfile()
        }
        .refreshable {
            await loadProfile()
        }
    }
    
    private func loadProfile() async {
        isLoading = true
        errorMessage = nil
        
        defer { isLoading = false }
        
        do {
            profile = try await fetchUserProfile(userID: userID)
        } catch {
            errorMessage = error.localizedDescription
        }
    }
}
```

### Multiple Async Operations
```swift
// Sequential execution
func loadUserData(userID: String) async throws -> (UserProfile, [Post], UserSettings) {
    let profile = try await fetchUserProfile(userID: userID)
    let posts = try await fetchUserPosts(userID: userID)
    let settings = try await fetchUserSettings(userID: userID)
    
    return (profile, posts, settings)
}

// Concurrent execution with async let
func loadUserDataConcurrently(userID: String) async throws -> (UserProfile, [Post], UserSettings) {
    async let profileTask = fetchUserProfile(userID: userID)
    async let postsTask = fetchUserPosts(userID: userID)
    async let settingsTask = fetchUserSettings(userID: userID)
    
    // All three requests execute concurrently
    let (profile, posts, settings) = try await (profileTask, postsTask, settingsTask)
    
    return (profile, posts, settings)
}

// Error handling with concurrent operations
func loadUserDataWithErrorHandling(userID: String) async -> UserDataResult {
    do {
        let (profile, posts, settings) = try await loadUserDataConcurrently(userID: userID)
        return .success(UserData(profile: profile, posts: posts, settings: settings))
    } catch {
        return .failure(error)
    }
}
```

## Task Management

### Task Creation and Lifecycle
```swift
class DataManager {
    private var loadingTask: Task<Void, Never>?
    
    func startDataLoading() {
        // Cancel existing task
        loadingTask?.cancel()
        
        loadingTask = Task {
            await performDataLoading()
        }
    }
    
    private func performDataLoading() async {
        for i in 1...100 {
            // Check for cancellation
            if Task.isCancelled {
                print("Data loading cancelled at item \(i)")
                return
            }
            
            await loadDataItem(i)
            
            // Yield to other tasks periodically
            if i % 10 == 0 {
                await Task.yield()
            }
        }
    }
    
    func stopDataLoading() {
        loadingTask?.cancel()
        loadingTask = nil
    }
}
```

### Task Groups for Dynamic Concurrency
```swift
// Load multiple users concurrently
func loadMultipleUsers(userIDs: [String]) async throws -> [UserProfile] {
    return try await withThrowingTaskGroup(of: UserProfile.self) { group in
        // Add tasks for each user
        for userID in userIDs {
            group.addTask {
                try await fetchUserProfile(userID: userID)
            }
        }
        
        // Collect results
        var profiles: [UserProfile] = []
        for try await profile in group {
            profiles.append(profile)
        }
        
        return profiles
    }
}

// Load images with error handling
func loadImages(urls: [URL]) async -> [Result<UIImage, Error>] {
    await withTaskGroup(of: Result<UIImage, Error>.self) { group in
        for url in urls {
            group.addTask {
                do {
                    let (data, _) = try await URLSession.shared.data(from: url)
                    guard let image = UIImage(data: data) else {
                        throw ImageError.invalidData
                    }
                    return .success(image)
                } catch {
                    return .failure(error)
                }
            }
        }
        
        var results: [Result<UIImage, Error>] = []
        for await result in group {
            results.append(result)
        }
        
        return results
    }
}
```

### Task Cancellation Patterns
```swift
class NetworkOperationManager {
    private var currentOperation: Task<Data, Error>?
    
    func performOperation(request: URLRequest) async throws -> Data {
        // Cancel any existing operation
        currentOperation?.cancel()
        
        currentOperation = Task {
            // Check cancellation before starting
            try Task.checkCancellation()
            
            let (data, _) = try await URLSession.shared.data(for: request)
            
            // Check cancellation after network call
            try Task.checkCancellation()
            
            return data
        }
        
        return try await currentOperation!.value
    }
    
    func cancelCurrentOperation() {
        currentOperation?.cancel()
    }
}

// Using cancellation in SwiftUI
struct SearchView: View {
    @State private var searchText = ""
    @State private var searchResults: [SearchResult] = []
    @State private var searchTask: Task<Void, Never>?
    
    var body: some View {
        VStack {
            SearchBar(text: $searchText)
            
            List(searchResults) { result in
                SearchResultRow(result: result)
            }
        }
        .onChange(of: searchText) { newValue in
            searchTask?.cancel()
            
            searchTask = Task {
                // Debounce search
                try? await Task.sleep(nanoseconds: 300_000_000) // 300ms
                
                if !Task.isCancelled {
                    await performSearch(query: newValue)
                }
            }
        }
    }
    
    private func performSearch(query: String) async {
        do {
            let results = try await searchService.search(query: query)
            
            if !Task.isCancelled {
                self.searchResults = results
            }
        } catch {
            if !Task.isCancelled {
                print("Search failed: \(error)")
            }
        }
    }
}
```

## Actors for Thread Safety

### Basic Actor Usage
```swift
actor UserDataCache {
    private var cache: [String: UserProfile] = [:]
    private var lastUpdated: [String: Date] = [:]
    
    func getUser(id: String) -> UserProfile? {
        return cache[id]
    }
    
    func setUser(_ user: UserProfile, id: String) {
        cache[id] = user
        lastUpdated[id] = Date()
    }
    
    func removeExpiredEntries(maxAge: TimeInterval) {
        let now = Date()
        let expiredKeys = lastUpdated.compactMap { key, date in
            now.timeIntervalSince(date) > maxAge ? key : nil
        }
        
        for key in expiredKeys {
            cache.removeValue(forKey: key)
            lastUpdated.removeValue(forKey: key)
        }
    }
    
    // Actor-isolated computed property
    var cacheSize: Int {
        cache.count
    }
}

// Using the actor
class UserService {
    private let cache = UserDataCache()
    
    func loadUser(id: String) async throws -> UserProfile {
        // Check cache first
        if let cachedUser = await cache.getUser(id: id) {
            return cachedUser
        }
        
        // Fetch from network
        let user = try await fetchUserFromNetwork(id: id)
        
        // Cache the result
        await cache.setUser(user, id: id)
        
        return user
    }
    
    func cleanupCache() async {
        await cache.removeExpiredEntries(maxAge: 3600) // 1 hour
    }
}
```

### MainActor for UI Updates
```swift
// MainActor-isolated class
@MainActor
class ViewModel: ObservableObject {
    @Published var data: [Item] = []
    @Published var isLoading = false
    @Published var errorMessage: String?
    
    func loadData() async {
        isLoading = true
        errorMessage = nil
        
        do {
            // Network call happens on background thread
            let items = try await dataService.fetchItems()
            
            // UI update happens on main thread (already MainActor-isolated)
            data = items
        } catch {
            errorMessage = error.localizedDescription
        }
        
        isLoading = false
    }
}

// Explicit MainActor calls
class DataProcessor {
    func processLargeDataset() async {
        // Heavy processing on background thread
        let processedData = await performHeavyComputation()
        
        // Update UI on main thread
        await MainActor.run {
            updateProgressIndicator(with: processedData)
        }
    }
    
    // Function isolated to MainActor
    @MainActor
    func updateUI(with data: ProcessedData) {
        // This function always runs on main thread
        progressView.progress = data.completionPercentage
        statusLabel.text = data.statusMessage
    }
}
```

### Custom Actor with Protocols
```swift
protocol DatabaseActorProtocol: Actor {
    func save<T: Codable>(_ object: T, key: String) async throws
    func load<T: Codable>(key: String, type: T.Type) async throws -> T?
    func delete(key: String) async throws
}

actor LocalDatabaseActor: DatabaseActorProtocol {
    private let fileManager = FileManager.default
    private let documentsURL: URL
    
    init() throws {
        documentsURL = try fileManager.url(for: .documentDirectory,
                                         in: .userDomainMask,
                                         appropriateFor: nil,
                                         create: false)
    }
    
    func save<T: Codable>(_ object: T, key: String) async throws {
        let data = try JSONEncoder().encode(object)
        let url = documentsURL.appendingPathComponent("\(key).json")
        try data.write(to: url)
    }
    
    func load<T: Codable>(key: String, type: T.Type) async throws -> T? {
        let url = documentsURL.appendingPathComponent("\(key).json")
        
        guard fileManager.fileExists(atPath: url.path) else {
            return nil
        }
        
        let data = try Data(contentsOf: url)
        return try JSONDecoder().decode(type, from: data)
    }
    
    func delete(key: String) async throws {
        let url = documentsURL.appendingPathComponent("\(key).json")
        try fileManager.removeItem(at: url)
    }
}
```

## Structured Concurrency Patterns

### AsyncSequence for Streaming Data
```swift
struct LocationStream: AsyncSequence, AsyncIteratorProtocol {
    typealias Element = CLLocation
    
    private let locationManager = CLLocationManager()
    private let continuation: AsyncStream<CLLocation>.Continuation
    private let stream: AsyncStream<CLLocation>
    
    init() {
        (stream, continuation) = AsyncStream.makeStream(of: CLLocation.self)
        setupLocationManager()
    }
    
    func makeAsyncIterator() -> LocationStream {
        return self
    }
    
    mutating func next() async -> CLLocation? {
        await stream.next()
    }
    
    private func setupLocationManager() {
        locationManager.delegate = LocationDelegate(continuation: continuation)
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
    }
}

// Usage
for await location in LocationStream() {
    print("New location: \(location.coordinate)")
    
    // Process location update
    await updateMap(with: location)
    
    // Break on certain condition
    if location.horizontalAccuracy < 10 {
        break
    }
}
```

### AsyncStream for Real-time Updates
```swift
class ChatService {
    private let webSocket: URLSessionWebSocketTask
    
    init(url: URL) {
        webSocket = URLSession.shared.webSocketTask(with: url)
    }
    
    func messages() -> AsyncStream<ChatMessage> {
        AsyncStream { continuation in
            webSocket.resume()
            
            Task {
                while !Task.isCancelled {
                    do {
                        let message = try await webSocket.receive()
                        
                        switch message {
                        case .string(let text):
                            if let chatMessage = try? JSONDecoder().decode(ChatMessage.self, from: Data(text.utf8)) {
                                continuation.yield(chatMessage)
                            }
                        case .data(let data):
                            if let chatMessage = try? JSONDecoder().decode(ChatMessage.self, from: data) {
                                continuation.yield(chatMessage)
                            }
                        @unknown default:
                            break
                        }
                    } catch {
                        continuation.finish(throwing: error)
                        break
                    }
                }
            }
            
            continuation.onTermination = { _ in
                self.webSocket.cancel()
            }
        }
    }
}

// Using in SwiftUI
struct ChatView: View {
    @State private var messages: [ChatMessage] = []
    private let chatService = ChatService(url: URL(string: "wss://chat.example.com")!)
    
    var body: some View {
        List(messages) { message in
            MessageRow(message: message)
        }
        .task {
            for await message in chatService.messages() {
                messages.append(message)
            }
        }
    }
}
```

## Legacy Concurrency Integration

### Bridging Callback APIs to Async/Await
```swift
extension CLLocationManager {
    func requestLocation() async throws -> CLLocation {
        return try await withCheckedThrowingContinuation { continuation in
            let delegate = LocationDelegate { location, error in
                if let location = location {
                    continuation.resume(returning: location)
                } else if let error = error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume(throwing: LocationError.unknown)
                }
            }
            
            self.delegate = delegate
            self.requestLocation()
        }
    }
}

// Using bridged API
class LocationService {
    private let locationManager = CLLocationManager()
    
    func getCurrentLocation() async throws -> CLLocation {
        return try await locationManager.requestLocation()
    }
}
```

### Converting Delegates to AsyncSequence
```swift
class NotificationCenter {
    static func notifications(for name: Notification.Name) -> AsyncStream<Notification> {
        AsyncStream { continuation in
            let observer = Foundation.NotificationCenter.default.addObserver(
                forName: name,
                object: nil,
                queue: nil
            ) { notification in
                continuation.yield(notification)
            }
            
            continuation.onTermination = { _ in
                Foundation.NotificationCenter.default.removeObserver(observer)
            }
        }
    }
}

// Usage
for await notification in NotificationCenter.notifications(for: .UIApplicationDidEnterBackground) {
    await handleAppBackgrounding()
}
```

## Performance Optimization for Mobile

### CPU-Intensive Task Management
```swift
class ImageProcessor {
    private let processingQueue = DispatchQueue(label: "image-processing", qos: .utility)
    
    func processImages(_ images: [UIImage]) async -> [ProcessedImage] {
        // Limit concurrent operations to avoid overwhelming device
        let semaphore = AsyncSemaphore(value: ProcessInfo.processInfo.processorCount)
        
        return await withTaskGroup(of: ProcessedImage?.self) { group in
            for image in images {
                group.addTask {
                    await semaphore.wait()
                    defer { semaphore.signal() }
                    
                    return await self.processImage(image)
                }
            }
            
            var results: [ProcessedImage] = []
            for await result in group {
                if let processedImage = result {
                    results.append(processedImage)
                }
            }
            
            return results
        }
    }
    
    private func processImage(_ image: UIImage) async -> ProcessedImage? {
        return await withCheckedContinuation { continuation in
            processingQueue.async {
                // Perform CPU-intensive processing
                let processed = self.applyFilters(to: image)
                continuation.resume(returning: processed)
            }
        }
    }
}

// Async Semaphore implementation
actor AsyncSemaphore {
    private var count: Int
    private var waiters: [CheckedContinuation<Void, Never>] = []
    
    init(value: Int) {
        self.count = value
    }
    
    func wait() async {
        if count > 0 {
            count -= 1
        } else {
            await withCheckedContinuation { continuation in
                waiters.append(continuation)
            }
        }
    }
    
    func signal() {
        if waiters.isEmpty {
            count += 1
        } else {
            let waiter = waiters.removeFirst()
            waiter.resume()
        }
    }
}
```

### Battery-Efficient Background Processing
```swift
class BackgroundDataProcessor {
    private let backgroundQueue = DispatchQueue(label: "background-processing", qos: .background)
    
    func processDataInBackground() async {
        await withTaskGroup(of: Void.self) { group in
            // Process data in chunks to avoid blocking
            let chunks = dataBatch.chunked(into: 100)
            
            for chunk in chunks {
                group.addTask {
                    await self.processChunk(chunk)
                    
                    // Yield periodically to allow other tasks
                    await Task.yield()
                    
                    // Check battery state and pause if needed
                    await self.checkBatteryAndPause()
                }
            }
        }
    }
    
    private func checkBatteryAndPause() async {
        let batteryLevel = UIDevice.current.batteryLevel
        let batteryState = UIDevice.current.batteryState
        
        if batteryLevel < 0.2 && batteryState != .charging {
            // Pause processing when battery is low
            await Task.sleep(nanoseconds: 5_000_000_000) // 5 seconds
        }
    }
}
```

## Error Handling in Concurrent Code

### Structured Error Handling
```swift
class DataSyncManager {
    enum SyncError: Error {
        case partialFailure(successCount: Int, errors: [Error])
        case totalFailure(Error)
    }
    
    func syncAllData() async throws {
        var errors: [Error] = []
        var successCount = 0
        
        await withTaskGroup(of: Result<Void, Error>.self) { group in
            // Add sync tasks
            group.addTask { await Result { try await self.syncUsers() } }
            group.addTask { await Result { try await self.syncPosts() } }
            group.addTask { await Result { try await self.syncSettings() } }
            
            // Collect results
            for await result in group {
                switch result {
                case .success:
                    successCount += 1
                case .failure(let error):
                    errors.append(error)
                }
            }
        }
        
        // Handle results
        if errors.isEmpty {
            // All succeeded
            return
        } else if successCount > 0 {
            throw SyncError.partialFailure(successCount: successCount, errors: errors)
        } else {
            throw SyncError.totalFailure(errors.first!)
        }
    }
}
```

### Timeout and Retry Patterns
```swift
extension Task where Success == Void, Failure == Error {
    static func withTimeout<T>(
        _ timeout: TimeInterval,
        operation: @Sendable @escaping () async throws -> T
    ) async throws -> T {
        return try await withThrowingTaskGroup(of: T.self) { group in
            group.addTask {
                try await operation()
            }
            
            group.addTask {
                try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
                throw TimeoutError()
            }
            
            let result = try await group.next()!
            group.cancelAll()
            return result
        }
    }
}

func performWithRetryAndTimeout<T>(
    maxAttempts: Int = 3,
    timeout: TimeInterval = 10,
    delay: TimeInterval = 1,
    operation: @Sendable @escaping () async throws -> T
) async throws -> T {
    var lastError: Error?
    
    for attempt in 1...maxAttempts {
        do {
            return try await Task.withTimeout(timeout, operation: operation)
        } catch {
            lastError = error
            
            if attempt < maxAttempts {
                try await Task.sleep(nanoseconds: UInt64(delay * Double(attempt) * 1_000_000_000))
            }
        }
    }
    
    throw lastError!
}
```

## Testing Concurrent Code

### Testing Async Functions
```swift
import XCTest

class ConcurrencyTests: XCTestCase {
    func testAsyncDataFetching() async throws {
        let service = DataService()
        let result = try await service.fetchData(id: "test")
        
        XCTAssertEqual(result.id, "test")
        XCTAssertFalse(result.name.isEmpty)
    }
    
    func testConcurrentOperations() async throws {
        let service = DataService()
        let ids = ["1", "2", "3", "4", "5"]
        
        let startTime = Date()
        let results = try await service.fetchMultipleData(ids: ids)
        let duration = Date().timeIntervalSince(startTime)
        
        XCTAssertEqual(results.count, ids.count)
        // Should complete faster than sequential operations
        XCTAssertLessThan(duration, 2.0)
    }
    
    func testTaskCancellation() async throws {
        let service = DataService()
        
        let task = Task {
            try await service.longRunningOperation()
        }
        
        // Cancel after short delay
        DispatchQueue.global().asyncAfter(deadline: .now() + 0.1) {
            task.cancel()
        }
        
        do {
            _ = try await task.value
            XCTFail("Task should have been cancelled")
        } catch is CancellationError {
            // Expected cancellation
        }
    }
}
```

### Actor Testing
```swift
class ActorTests: XCTestCase {
    func testActorIsolation() async {
        let cache = UserDataCache()
        
        let user = UserProfile(id: "123", name: "Test User")
        await cache.setUser(user, id: "123")
        
        let retrievedUser = await cache.getUser(id: "123")
        XCTAssertEqual(retrievedUser?.id, "123")
    }
    
    func testConcurrentActorAccess() async {
        let cache = UserDataCache()
        let users = (1...100).map { UserProfile(id: "\($0)", name: "User \($0)") }
        
        // Concurrent writes
        await withTaskGroup(of: Void.self) { group in
            for user in users {
                group.addTask {
                    await cache.setUser(user, id: user.id)
                }
            }
        }
        
        let cacheSize = await cache.cacheSize
        XCTAssertEqual(cacheSize, 100)
    }
}
```

## Best Practices for Mobile Concurrency

### Performance Guidelines
1. **Use async/await for network operations** - cleaner than callbacks
2. **Limit concurrent operations** - respect device capabilities
3. **Cancel tasks when views disappear** - prevent memory leaks
4. **Use actors for shared mutable state** - thread safety
5. **Prefer structured concurrency** - better error handling and cancellation

### Memory Management
```swift
class ConcurrencyBestPractices {
    // GOOD: Weak references in async closures
    func loadDataWithWeakSelf() async {
        await withTaskGroup(of: Void.self) { [weak self] group in
            group.addTask { [weak self] in
                await self?.loadUserData()
            }
            
            group.addTask { [weak self] in
                await self?.loadSettings()
            }
        }
    }
    
    // GOOD: Proper task cleanup
    deinit {
        // Tasks are automatically cancelled when reference is lost
        // But explicit cancellation is clearer
        currentTask?.cancel()
    }
    
    private var currentTask: Task<Void, Never>?
}
```

### UI Responsiveness
```swift
// Keep UI responsive during heavy operations
class ResponsiveViewController: UIViewController {
    @IBAction func processLargeDataset() {
        Task {
            await showLoadingIndicator()
            
            // Heavy processing on background
            let results = await withTaskGroup(of: ProcessedItem.self) { group in
                for item in largeDataset {
                    group.addTask {
                        await processItem(item)
                    }
                    
                    // Yield periodically to keep UI responsive
                    if group.addedTaskCount % 10 == 0 {
                        await Task.yield()
                    }
                }
                
                var results: [ProcessedItem] = []
                for await result in group {
                    results.append(result)
                }
                return results
            }
            
            await updateUI(with: results)
            await hideLoadingIndicator()
        }
    }
    
    @MainActor
    private func updateUI(with results: [ProcessedItem]) {
        // UI updates automatically on main thread
        tableView.reloadData()
    }
}
```

## References
- [Swift Concurrency Manifesto](https://gist.github.com/lattner/31ed37682ef1576b16bca1432ea9f782)
- [Async/Await Documentation](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html)
- [Meet async/await in Swift - WWDC 2021](https://developer.apple.com/videos/play/wwdc2021/10132/)
- [Protect mutable state with Swift actors - WWDC 2021](https://developer.apple.com/videos/play/wwdc2021/10133/)
- [Swift Actors Proposal](https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md)