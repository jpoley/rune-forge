# Swift Types and Collections for Mobile Development

## Swift Type System Overview

Swift's type system provides safety, performance, and expressiveness crucial for mobile development. Understanding value types, reference types, protocols, and generics enables building robust iOS applications with clean architecture and optimal performance.

## Fundamental Types

### Value Types vs Reference Types
```swift
// Value Types (Structs, Enums, Tuples) - Copied on assignment
struct UserSettings {
    var isDarkModeEnabled: Bool
    var notificationsEnabled: Bool
    var preferredLanguage: String
}

let settings1 = UserSettings(isDarkModeEnabled: true, notificationsEnabled: true, preferredLanguage: "en")
var settings2 = settings1  // Creates a copy
settings2.isDarkModeEnabled = false  // Only affects settings2

// Reference Types (Classes) - Shared references
class UserSession {
    var userID: String
    var authToken: String?
    
    init(userID: String) {
        self.userID = userID
    }
}

let session1 = UserSession(userID: "123")
let session2 = session1  // Both reference the same object
session2.userID = "456"  // Changes both session1 and session2
```

### Basic Types for Mobile Apps
```swift
// Numbers
let score: Int = 1000
let progress: Float = 0.75
let latitude: Double = 37.7749
let userId: UInt = 12345

// Boolean
let isLoggedIn: Bool = true
let hasNotifications: Bool = false

// Text
let username: String = "john_doe"
let emoji: Character = "ðŸŽ‰"

// Optional types (crucial for iOS development)
var profileImage: UIImage?
var currentLocation: CLLocation?
var errorMessage: String?

// Tuples for simple data grouping
let coordinate = (latitude: 37.7749, longitude: -122.4194)
let httpResponse = (statusCode: 200, data: responseData)
```

### Type Aliases for Clarity
```swift
// Common mobile development type aliases
typealias UserID = String
typealias Timestamp = TimeInterval
typealias Coordinate = (latitude: Double, longitude: Double)
typealias CompletionHandler<T> = (Result<T, Error>) -> Void

// Usage
func fetchUser(id: UserID, completion: @escaping CompletionHandler<User>) {
    // Implementation
}

// SwiftUI type aliases
typealias ViewBuilder<Content> = () -> Content where Content: View
```

## Enumerations for State Management

### Basic Enums
```swift
enum NetworkStatus {
    case connected
    case disconnected
    case connecting
}

enum AppTheme {
    case light
    case dark
    case system  // Follow system setting
}

enum UserRole {
    case guest
    case member
    case premium
    case admin
}
```

### Enums with Associated Values (Perfect for iOS)
```swift
enum LoadingState<T> {
    case idle
    case loading
    case loaded(T)
    case failed(Error)
}

enum NavigationDestination {
    case profile(UserID)
    case settings(SettingsCategory)
    case webView(URL)
    case camera(CameraMode)
}

enum APIResult<T> {
    case success(data: T, cached: Bool)
    case failure(error: APIError, retryable: Bool)
    case loading(progress: Double)
}

// Usage in SwiftUI
struct ContentView: View {
    @State private var loadingState: LoadingState<[User]> = .idle
    
    var body: some View {
        switch loadingState {
        case .idle:
            Button("Load Users") {
                loadUsers()
            }
        case .loading:
            ProgressView("Loading users...")
        case .loaded(let users):
            List(users) { user in
                UserRow(user: user)
            }
        case .failed(let error):
            ErrorView(error: error) {
                loadUsers()
            }
        }
    }
}
```

### Raw Value Enums
```swift
enum HTTPStatusCode: Int {
    case ok = 200
    case notFound = 404
    case serverError = 500
}

enum NotificationType: String, CaseIterable {
    case message = "message"
    case like = "like"
    case comment = "comment"
    case follow = "follow"
    
    var displayName: String {
        switch self {
        case .message: return "Messages"
        case .like: return "Likes"
        case .comment: return "Comments"
        case .follow: return "Followers"
        }
    }
    
    var icon: String {
        switch self {
        case .message: return "message"
        case .like: return "heart"
        case .comment: return "bubble.left"
        case .follow: return "person.badge.plus"
        }
    }
}
```

## Structures for Data Models

### Simple Data Models
```swift
struct User: Identifiable, Codable {
    let id: String
    let username: String
    let email: String
    let profileImageURL: String?
    let createdAt: Date
    
    // Computed properties
    var displayName: String {
        username.isEmpty ? email : username
    }
    
    var profileImageUrl: URL? {
        guard let urlString = profileImageURL else { return nil }
        return URL(string: urlString)
    }
}

struct Post: Identifiable, Codable {
    let id: String
    let authorId: String
    let content: String
    let imageUrls: [String]
    let createdAt: Date
    let updatedAt: Date?
    
    // Nested types
    struct Comment: Identifiable, Codable {
        let id: String
        let authorId: String
        let content: String
        let createdAt: Date
    }
    
    let comments: [Comment]
    let likeCount: Int
}
```

### Structs with Methods
```swift
struct ValidationResult {
    let isValid: Bool
    let errors: [String]
    
    static let valid = ValidationResult(isValid: true, errors: [])
    
    static func invalid(errors: [String]) -> ValidationResult {
        return ValidationResult(isValid: false, errors: errors)
    }
    
    func adding(error: String) -> ValidationResult {
        return ValidationResult(isValid: false, errors: errors + [error])
    }
}

struct FormData {
    var email: String = ""
    var password: String = ""
    var confirmPassword: String = ""
    
    mutating func reset() {
        email = ""
        password = ""
        confirmPassword = ""
    }
    
    func validate() -> ValidationResult {
        var result = ValidationResult.valid
        
        if email.isEmpty || !email.contains("@") {
            result = result.adding(error: "Invalid email address")
        }
        
        if password.count < 8 {
            result = result.adding(error: "Password must be at least 8 characters")
        }
        
        if password != confirmPassword {
            result = result.adding(error: "Passwords do not match")
        }
        
        return result
    }
}
```

### Property Wrappers in Structs
```swift
@propertyWrapper
struct Clamped<Value: Comparable> {
    private var value: Value
    private let range: ClosedRange<Value>
    
    var wrappedValue: Value {
        get { value }
        set { value = min(max(newValue, range.lowerBound), range.upperBound) }
    }
    
    init(wrappedValue: Value, _ range: ClosedRange<Value>) {
        self.range = range
        self.value = min(max(wrappedValue, range.lowerBound), range.upperBound)
    }
}

struct AudioSettings {
    @Clamped(0...100) var volume: Int = 50
    @Clamped(0.0...2.0) var playbackSpeed: Double = 1.0
    @Clamped(1...10) var bassLevel: Int = 5
}

var settings = AudioSettings()
settings.volume = 150  // Automatically clamped to 100
settings.playbackSpeed = -1.0  // Automatically clamped to 0.0
```

## Classes for Reference Semantics

### View Controllers and Managers
```swift
class UserProfileViewController: UIViewController {
    // IBOutlets
    @IBOutlet weak var profileImageView: UIImageView!
    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var bioLabel: UILabel!
    
    // Properties
    private let viewModel: UserProfileViewModel
    private let imageLoader = ImageLoader()
    
    // Dependency injection through initializer
    init(viewModel: UserProfileViewModel) {
        self.viewModel = viewModel
        super.init(nibName: nil, bundle: nil)
    }
    
    required init?(coder: NSCoder) {
        fatalError("Use init(viewModel:) instead")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupUI()
        bindViewModel()
    }
    
    private func setupUI() {
        title = "Profile"
        navigationItem.rightBarButtonItem = UIBarButtonItem(
            barButtonSystemItem: .edit,
            target: self,
            action: #selector(editProfile)
        )
    }
    
    @objc private func editProfile() {
        // Navigate to edit profile
    }
}

// Service classes for business logic
class NetworkManager {
    static let shared = NetworkManager()
    
    private let session: URLSession
    private let decoder: JSONDecoder
    
    private init() {
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 30
        session = URLSession(configuration: config)
        
        decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601
    }
    
    func fetch<T: Codable>(_ type: T.Type, from url: URL) async throws -> T {
        let (data, response) = try await session.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              200...299 ~= httpResponse.statusCode else {
            throw NetworkError.invalidResponse
        }
        
        return try decoder.decode(type, from: data)
    }
}
```

### Class Inheritance Patterns
```swift
// Base view controller with common functionality
class BaseViewController: UIViewController {
    private let loadingView = LoadingView()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupCommonUI()
    }
    
    private func setupCommonUI() {
        view.backgroundColor = .systemBackground
        setupLoadingView()
    }
    
    // Common functionality
    func showLoading() {
        loadingView.isHidden = false
        loadingView.startAnimating()
    }
    
    func hideLoading() {
        loadingView.stopAnimating()
        loadingView.isHidden = true
    }
    
    func showError(_ message: String) {
        let alert = UIAlertController(title: "Error", message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "OK", style: .default))
        present(alert, animated: true)
    }
}

// Specific view controllers inherit common functionality
class UserListViewController: BaseViewController {
    @IBOutlet weak var tableView: UITableView!
    
    private var users: [User] = []
    private let userService = UserService()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupTableView()
        loadUsers()
    }
    
    private func loadUsers() {
        showLoading()
        
        Task {
            do {
                users = try await userService.fetchUsers()
                await MainActor.run {
                    tableView.reloadData()
                    hideLoading()
                }
            } catch {
                await MainActor.run {
                    hideLoading()
                    showError(error.localizedDescription)
                }
            }
        }
    }
}
```

## Protocols for Flexible Architecture

### Basic Protocol Definitions
```swift
protocol Identifiable {
    var id: String { get }
}

protocol Displayable {
    var displayText: String { get }
    var displayImage: UIImage? { get }
}

protocol Cacheable {
    var cacheKey: String { get }
    var expirationDate: Date { get }
}

// Protocol composition
protocol CacheableDisplayable: Cacheable, Displayable {}

// Implementation
struct MenuItem: CacheableDisplayable {
    let id: String
    let name: String
    let price: Double
    let imageURL: String?
    
    var displayText: String { "\(name) - $\(price)" }
    var displayImage: UIImage? { /* load from imageURL */ nil }
    var cacheKey: String { "menu_item_\(id)" }
    var expirationDate: Date { Date().addingTimeInterval(3600) }
}
```

### Delegate Patterns
```swift
protocol NetworkManagerDelegate: AnyObject {
    func networkManager(_ manager: NetworkManager, didReceiveData data: Data)
    func networkManager(_ manager: NetworkManager, didFailWithError error: Error)
    func networkManagerDidStartLoading(_ manager: NetworkManager)
    func networkManagerDidFinishLoading(_ manager: NetworkManager)
}

class NetworkManager {
    weak var delegate: NetworkManagerDelegate?
    
    func performRequest(url: URL) {
        delegate?.networkManagerDidStartLoading(self)
        
        URLSession.shared.dataTask(with: url) { [weak self] data, response, error in
            guard let self = self else { return }
            
            DispatchQueue.main.async {
                if let error = error {
                    self.delegate?.networkManager(self, didFailWithError: error)
                } else if let data = data {
                    self.delegate?.networkManager(self, didReceiveData: data)
                }
                
                self.delegate?.networkManagerDidFinishLoading(self)
            }
        }.resume()
    }
}
```

### Protocol Extensions
```swift
protocol APIEndpoint {
    var baseURL: URL { get }
    var path: String { get }
    var method: HTTPMethod { get }
    var headers: [String: String] { get }
}

extension APIEndpoint {
    // Default implementations
    var baseURL: URL { URL(string: "https://api.example.com")! }
    var headers: [String: String] { ["Content-Type": "application/json"] }
    
    // Computed properties
    var fullURL: URL {
        baseURL.appendingPathComponent(path)
    }
    
    var urlRequest: URLRequest {
        var request = URLRequest(url: fullURL)
        request.httpMethod = method.rawValue
        headers.forEach { request.setValue($1, forHTTPHeaderField: $0) }
        return request
    }
}

// Usage
enum UserAPI: APIEndpoint {
    case profile(userID: String)
    case updateProfile(userID: String)
    case deleteAccount(userID: String)
    
    var path: String {
        switch self {
        case .profile(let userID):
            return "/users/\(userID)"
        case .updateProfile(let userID):
            return "/users/\(userID)"
        case .deleteAccount(let userID):
            return "/users/\(userID)"
        }
    }
    
    var method: HTTPMethod {
        switch self {
        case .profile:
            return .GET
        case .updateProfile:
            return .PUT
        case .deleteAccount:
            return .DELETE
        }
    }
}
```

### Associated Types
```swift
protocol Repository {
    associatedtype Item
    associatedtype ID
    
    func fetch(id: ID) async throws -> Item
    func save(item: Item) async throws
    func delete(id: ID) async throws
    func fetchAll() async throws -> [Item]
}

// Implementation
class UserRepository: Repository {
    typealias Item = User
    typealias ID = String
    
    private let networkManager = NetworkManager.shared
    
    func fetch(id: String) async throws -> User {
        let url = URL(string: "https://api.example.com/users/\(id)")!
        return try await networkManager.fetch(User.self, from: url)
    }
    
    func save(item: User) async throws {
        // Implementation
    }
    
    func delete(id: String) async throws {
        // Implementation
    }
    
    func fetchAll() async throws -> [User] {
        let url = URL(string: "https://api.example.com/users")!
        return try await networkManager.fetch([User].self, from: url)
    }
}

// Generic service using the repository
class DataService<R: Repository> {
    private let repository: R
    
    init(repository: R) {
        self.repository = repository
    }
    
    func loadItem(id: R.ID) async throws -> R.Item {
        return try await repository.fetch(id: id)
    }
    
    func saveItem(_ item: R.Item) async throws {
        try await repository.save(item: item)
    }
}
```

## Generics for Type Safety

### Generic Functions
```swift
// Generic network function
func fetchData<T: Codable>(from url: URL, type: T.Type) async throws -> T {
    let (data, _) = try await URLSession.shared.data(from: url)
    return try JSONDecoder().decode(type, from: data)
}

// Generic caching function
func cache<T: Codable>(_ object: T, forKey key: String) {
    let data = try? JSONEncoder().encode(object)
    UserDefaults.standard.set(data, forKey: key)
}

func loadFromCache<T: Codable>(_ type: T.Type, forKey key: String) -> T? {
    guard let data = UserDefaults.standard.data(forKey: key) else { return nil }
    return try? JSONDecoder().decode(type, from: data)
}

// Usage
let user = try await fetchData(from: userURL, type: User.self)
cache(user, forKey: "current_user")
let cachedUser = loadFromCache(User.self, forKey: "current_user")
```

### Generic Types
```swift
struct LoadingWrapper<T> {
    private(set) var isLoading: Bool = false
    private(set) var data: T?
    private(set) var error: Error?
    
    mutating func setLoading() {
        isLoading = true
        error = nil
    }
    
    mutating func setSuccess(_ data: T) {
        isLoading = false
        self.data = data
        error = nil
    }
    
    mutating func setError(_ error: Error) {
        isLoading = false
        data = nil
        self.error = error
    }
}

// Generic view model
class DataViewModel<T>: ObservableObject {
    @Published private(set) var state = LoadingWrapper<T>()
    
    private let loader: () async throws -> T
    
    init(loader: @escaping () async throws -> T) {
        self.loader = loader
    }
    
    @MainActor
    func load() async {
        state.setLoading()
        
        do {
            let data = try await loader()
            state.setSuccess(data)
        } catch {
            state.setError(error)
        }
    }
}

// Usage
let userViewModel = DataViewModel<User> {
    try await userService.fetchCurrentUser()
}

let postsViewModel = DataViewModel<[Post]> {
    try await postService.fetchRecentPosts()
}
```

### Constrained Generics
```swift
protocol Identifiable {
    associatedtype ID: Hashable
    var id: ID { get }
}

// Generic function with constraints
func findItems<T: Identifiable>(in collection: [T], withIDs ids: [T.ID]) -> [T] {
    return collection.filter { item in
        ids.contains(item.id)
    }
}

// Generic class with multiple constraints
class TableViewDataSource<T: Identifiable & Displayable>: NSObject, UITableViewDataSource {
    private var items: [T] = []
    
    func update(with items: [T]) {
        self.items = items
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return items.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath)
        let item = items[indexPath.row]
        
        cell.textLabel?.text = item.displayText
        cell.imageView?.image = item.displayImage
        
        return cell
    }
}
```

## Collections in Mobile Development

### Arrays for Ordered Data
```swift
// Common mobile array operations
var users: [User] = []
var posts: [Post] = []
var notifications: [Notification] = []

// Adding items
users.append(newUser)
posts.insert(newPost, at: 0)  // Add at beginning for timeline
notifications += newNotifications

// Removing items
users.removeAll { $0.id == userIDToRemove }
posts.removeFirst()  // Remove oldest post
notifications.removeLast(5)  // Keep only recent notifications

// Searching and filtering
let activeUsers = users.filter { $0.isActive }
let recentPosts = posts.filter { $0.createdAt > Date().addingTimeInterval(-86400) }
let unreadNotifications = notifications.filter { !$0.isRead }

// Mapping and transforming
let userIDs = users.map { $0.id }
let postTitles = posts.compactMap { $0.title }
let notificationMessages = notifications.map { $0.message }

// Sorting
users.sort { $0.name < $1.name }
posts.sort { $0.createdAt > $1.createdAt }  // Most recent first
notifications.sort { $0.timestamp > $1.timestamp }

// Finding items
if let user = users.first(where: { $0.email == targetEmail }) {
    // Found user
}

let postIndex = posts.firstIndex { $0.id == targetPostID }
```

### Sets for Unique Collections
```swift
// Managing unique items
var followedUserIDs: Set<String> = []
var favoritePostIDs: Set<String> = []
var enabledFeatures: Set<Feature> = []

// Set operations
followedUserIDs.insert("user123")
followedUserIDs.remove("user456")

let isFollowing = followedUserIDs.contains("user123")
let followedCount = followedUserIDs.count

// Set algebra for feature flags
let userFeatures: Set<Feature> = [.notifications, .darkMode, .analytics]
let premiumFeatures: Set<Feature> = [.analytics, .advancedSearch, .export]

let availableFeatures = userFeatures.union(premiumFeatures)
let premiumOnlyFeatures = premiumFeatures.subtracting(userFeatures)
let commonFeatures = userFeatures.intersection(premiumFeatures)

// Performance benefit: O(1) lookup time
func isUserFollowed(_ userID: String) -> Bool {
    return followedUserIDs.contains(userID)  // Much faster than array.contains
}
```

### Dictionaries for Key-Value Storage
```swift
// User preferences and caches
var userPreferences: [String: Any] = [:]
var imageCache: [String: UIImage] = [:]
var apiCache: [String: (data: Data, timestamp: Date)] = [:]

// Setting values
userPreferences["theme"] = "dark"
userPreferences["notifications_enabled"] = true
userPreferences["last_sync"] = Date()

// Getting values with type safety
let theme = userPreferences["theme"] as? String ?? "light"
let notificationsEnabled = userPreferences["notifications_enabled"] as? Bool ?? false
let lastSync = userPreferences["last_sync"] as? Date

// Cache management
func cacheImage(_ image: UIImage, forURL url: String) {
    imageCache[url] = image
    
    // Prevent memory bloat
    if imageCache.count > 100 {
        // Remove oldest entries
        let sortedKeys = imageCache.keys.sorted()
        for key in sortedKeys.prefix(20) {
            imageCache.removeValue(forKey: key)
        }
    }
}

func getCachedImage(forURL url: String) -> UIImage? {
    return imageCache[url]
}

// Grouping data
let postsByUser = Dictionary(grouping: posts) { $0.authorID }
let notificationsByType = Dictionary(grouping: notifications) { $0.type }

// Performance: O(1) average lookup time
func getUserPosts(userID: String) -> [Post] {
    return postsByUser[userID] ?? []
}
```

### Advanced Collection Operations
```swift
// Chunking for pagination
extension Array {
    func chunked(into size: Int) -> [[Element]] {
        return stride(from: 0, to: count, by: size).map {
            Array(self[$0..<Swift.min($0 + size, count)])
        }
    }
}

let posts = Array(1...100).map { Post(id: "\($0)") }
let pages = posts.chunked(into: 20)  // 5 pages of 20 posts each

// Safe subscripting
extension Collection {
    subscript(safe index: Index) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}

let firstUser = users[safe: 0]  // Returns nil if array is empty
let fifthNotification = notifications[safe: 4]

// Functional composition for data processing
let processedUsers = users
    .filter { $0.isActive }
    .sorted { $0.lastLoginDate > $1.lastLoginDate }
    .prefix(10)
    .map { UserViewModel(user: $0) }

// Reduce for aggregations
let totalLikes = posts.reduce(0) { $0 + $1.likeCount }
let userPostCounts = posts.reduce(into: [String: Int]()) { counts, post in
    counts[post.authorID, default: 0] += 1
}
```

## Custom Collections
```swift
// Custom collection for managing form fields
struct FormFieldCollection: Collection {
    private var fields: [FormField]
    
    init(fields: [FormField] = []) {
        self.fields = fields
    }
    
    // Collection protocol requirements
    var startIndex: Int { fields.startIndex }
    var endIndex: Int { fields.endIndex }
    
    func index(after i: Int) -> Int {
        return fields.index(after: i)
    }
    
    subscript(index: Int) -> FormField {
        return fields[index]
    }
    
    // Custom functionality
    mutating func addField(_ field: FormField) {
        fields.append(field)
    }
    
    var isValid: Bool {
        return fields.allSatisfy { $0.isValid }
    }
    
    var errors: [String] {
        return fields.compactMap { $0.errorMessage }
    }
    
    func field(withID id: String) -> FormField? {
        return fields.first { $0.id == id }
    }
}

// Usage
var form = FormFieldCollection()
form.addField(FormField(id: "email", value: "", validator: EmailValidator()))
form.addField(FormField(id: "password", value: "", validator: PasswordValidator()))

for field in form {
    print("Field \(field.id): \(field.isValid ? "Valid" : "Invalid")")
}

if !form.isValid {
    print("Form errors: \(form.errors)")
}
```

## Type Safety Patterns for Mobile

### Result Builders for DSL
```swift
@resultBuilder
struct NavigationBuilder {
    static func buildBlock(_ components: NavigationItem...) -> [NavigationItem] {
        return components
    }
    
    static func buildEither(first component: [NavigationItem]) -> [NavigationItem] {
        return component
    }
    
    static func buildEither(second component: [NavigationItem]) -> [NavigationItem] {
        return component
    }
    
    static func buildOptional(_ component: [NavigationItem]?) -> [NavigationItem] {
        return component ?? []
    }
}

struct NavigationItem {
    let title: String
    let icon: String
    let destination: AnyView
}

func buildNavigation(@NavigationBuilder _ content: () -> [NavigationItem]) -> [NavigationItem] {
    return content()
}

// Usage
let navigationItems = buildNavigation {
    NavigationItem(title: "Profile", icon: "person", destination: AnyView(ProfileView()))
    NavigationItem(title: "Settings", icon: "gear", destination: AnyView(SettingsView()))
    
    if userIsPremium {
        NavigationItem(title: "Premium", icon: "star", destination: AnyView(PremiumView()))
    }
}
```

### Phantom Types for Compile-Time Safety
```swift
enum Authenticated {}
enum Unauthenticated {}

struct APIClient<State> {
    private let session: URLSession
    
    private init(session: URLSession) {
        self.session = session
    }
    
    static func unauthenticated() -> APIClient<Unauthenticated> {
        return APIClient<Unauthenticated>(session: .shared)
    }
}

extension APIClient where State == Unauthenticated {
    func authenticate(username: String, password: String) async throws -> APIClient<Authenticated> {
        // Perform authentication
        let authToken = try await performAuthentication(username: username, password: password)
        
        let config = URLSessionConfiguration.default
        config.httpAdditionalHeaders = ["Authorization": "Bearer \(authToken)"]
        
        return APIClient<Authenticated>(session: URLSession(configuration: config))
    }
}

extension APIClient where State == Authenticated {
    func fetchUserProfile() async throws -> UserProfile {
        // Only available on authenticated client
        let url = URL(string: "https://api.example.com/profile")!
        let (data, _) = try await session.data(from: url)
        return try JSONDecoder().decode(UserProfile.self, from: data)
    }
    
    func logout() -> APIClient<Unauthenticated> {
        return APIClient<Unauthenticated>.unauthenticated()
    }
}

// Usage - compile-time safety
let client = APIClient.unauthenticated()
// client.fetchUserProfile()  // Compile error - not authenticated

let authenticatedClient = try await client.authenticate(username: "user", password: "pass")
let profile = try await authenticatedClient.fetchUserProfile()  // OK
```

## Performance Considerations

### Memory Efficiency
```swift
// Use structs for simple data models (value semantics)
struct UserPreference {  // Better than class for simple data
    let key: String
    let value: String
    let type: PreferenceType
}

// Use enums instead of string constants
enum Theme: String, CaseIterable {  // Better than string constants
    case light = "light"
    case dark = "dark"
    case system = "system"
}

// Use weak references in collections to prevent retain cycles
class WeakBox<T: AnyObject> {
    weak var value: T?
    
    init(_ value: T) {
        self.value = value
    }
}

class ObserverCollection<T: AnyObject> {
    private var observers: [WeakBox<T>] = []
    
    func add(_ observer: T) {
        observers.append(WeakBox(observer))
        cleanupDeallocatedObservers()
    }
    
    private func cleanupDeallocatedObservers() {
        observers = observers.filter { $0.value != nil }
    }
    
    func notifyObservers(_ action: (T) -> Void) {
        cleanupDeallocatedObservers()
        observers.forEach { weakBox in
            if let observer = weakBox.value {
                action(observer)
            }
        }
    }
}
```

### Copy-on-Write for Large Collections
```swift
struct LargeDataSet {
    private var storage: Storage
    
    init() {
        storage = Storage()
    }
    
    private mutating func ensureUniqueStorage() {
        if !isKnownUniquelyReferenced(&storage) {
            storage = Storage(copying: storage)
        }
    }
    
    mutating func append(_ item: DataItem) {
        ensureUniqueStorage()
        storage.items.append(item)
    }
    
    var items: [DataItem] {
        return storage.items
    }
    
    private class Storage {
        var items: [DataItem] = []
        
        init() {}
        
        init(copying other: Storage) {
            self.items = other.items
        }
    }
}
```

## References
- [Swift Language Guide - Types](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html)
- [Protocols and Extensions](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html)
- [Generics Documentation](https://docs.swift.org/swift-book/LanguageGuide/Generics.html)
- [Collection Types](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html)
- [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)