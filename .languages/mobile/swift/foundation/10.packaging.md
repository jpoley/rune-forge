# Swift Mobile - Packaging & Distribution

## Swift Package Manager (SPM)

### iOS Framework Package Structure
```
MyiOSLibrary/
‚îú‚îÄ‚îÄ Package.swift                    # Package manifest
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ Sources/
‚îÇ   ‚îî‚îÄ‚îÄ MyiOSLibrary/
‚îÇ       ‚îú‚îÄ‚îÄ MyiOSLibrary.swift      # Main library file
‚îÇ       ‚îú‚îÄ‚îÄ ViewControllers/
‚îÇ       ‚îú‚îÄ‚îÄ Views/
‚îÇ       ‚îî‚îÄ‚îÄ Extensions/
‚îú‚îÄ‚îÄ Tests/
‚îÇ   ‚îî‚îÄ‚îÄ MyiOSLibraryTests/
‚îÇ       ‚îî‚îÄ‚îÄ MyiOSLibraryTests.swift
‚îî‚îÄ‚îÄ Resources/                       # Assets, xibs, storyboards
    ‚îú‚îÄ‚îÄ Images/
    ‚îî‚îÄ‚îÄ Localizations/
```

### Package.swift for iOS Library
```swift
// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "MyiOSLibrary",
    defaultLocalization: "en",
    platforms: [
        .iOS(.v15),
        .macOS(.v12),
        .tvOS(.v15),
        .watchOS(.v8),
        .macCatalyst(.v15)
    ],
    products: [
        .library(
            name: "MyiOSLibrary",
            targets: ["MyiOSLibrary"]
        ),
        .library(
            name: "MyiOSLibraryDynamic", 
            type: .dynamic,
            targets: ["MyiOSLibrary"]
        )
    ],
    dependencies: [
        .package(url: "https://github.com/Alamofire/Alamofire.git", from: "5.8.0"),
        .package(url: "https://github.com/onevcat/Kingfisher.git", from: "7.9.0"),
        .package(url: "https://github.com/realm/realm-swift.git", from: "10.44.0"),
        .package(url: "https://github.com/stephencelis/SQLite.swift.git", from: "0.14.1")
    ],
    targets: [
        .target(
            name: "MyiOSLibrary",
            dependencies: [
                "Alamofire",
                "Kingfisher",
                .product(name: "RealmSwift", package: "realm-swift"),
                .product(name: "SQLite", package: "SQLite.swift")
            ],
            resources: [
                .process("Resources"),
                .copy("PrivacyInfo.xcprivacy")
            ],
            swiftSettings: [
                .enableUpcomingFeature("BareSlashRegexLiterals"),
                .enableExperimentalFeature("StrictConcurrency"),
                .define("DEBUG", .when(configuration: .debug))
            ]
        ),
        .testTarget(
            name: "MyiOSLibraryTests",
            dependencies: ["MyiOSLibrary"],
            resources: [
                .copy("TestResources")
            ]
        )
    ]
)
```

### Advanced Package Configuration
```swift
// Package.swift with conditional dependencies
import PackageDescription

let package = Package(
    name: "AdvancediOSLibrary",
    platforms: [
        .iOS(.v15)
    ],
    products: [
        .library(name: "Core", targets: ["Core"]),
        .library(name: "UI", targets: ["UI"]),
        .library(name: "Networking", targets: ["Networking"]),
        .executable(name: "CodeGen", targets: ["CodeGen"])
    ],
    dependencies: [
        // Conditional dependencies based on platform
        .package(url: "https://github.com/apple/swift-argument-parser", from: "1.2.0"),
        .package(url: "https://github.com/apple/swift-collections", from: "1.0.0"),
        .package(url: "https://github.com/pointfreeco/swift-composable-architecture", from: "1.2.0")
    ],
    targets: [
        .target(
            name: "Core",
            dependencies: [
                .product(name: "Collections", package: "swift-collections")
            ],
            path: "Sources/Core"
        ),
        .target(
            name: "UI",
            dependencies: [
                "Core",
                .product(name: "ComposableArchitecture", package: "swift-composable-architecture")
            ],
            path: "Sources/UI",
            resources: [
                .process("Assets.xcassets"),
                .process("Localizable.strings")
            ]
        ),
        .target(
            name: "Networking",
            dependencies: ["Core"],
            path: "Sources/Networking"
        ),
        .executableTarget(
            name: "CodeGen",
            dependencies: [
                .product(name: "ArgumentParser", package: "swift-argument-parser")
            ],
            path: "Sources/CodeGen"
        ),
        .testTarget(
            name: "CoreTests",
            dependencies: ["Core"]
        ),
        .testTarget(
            name: "UITests",
            dependencies: ["UI"]
        )
    ]
)
```

## CocoaPods Integration

### Podspec for iOS Library
```ruby
# MyiOSLibrary.podspec
Pod::Spec.new do |spec|
  spec.name                     = 'MyiOSLibrary'
  spec.version                  = '1.2.0'
  spec.summary                  = 'A comprehensive iOS library for mobile development'
  spec.description              = <<-DESC
    MyiOSLibrary provides essential utilities and components for iOS app development,
    including networking, UI components, and data persistence layers.
  DESC

  spec.homepage                 = 'https://github.com/username/MyiOSLibrary'
  spec.license                  = { :type => 'MIT', :file => 'LICENSE' }
  spec.author                   = { 'Your Name' => 'email@example.com' }
  spec.source                   = { 
    :git => 'https://github.com/username/MyiOSLibrary.git', 
    :tag => spec.version.to_s 
  }

  # Platform support
  spec.ios.deployment_target    = '15.0'
  spec.swift_version            = '5.9'

  # Source files
  spec.source_files             = 'Sources/MyiOSLibrary/**/*.{swift,h,m}'
  spec.public_header_files      = 'Sources/MyiOSLibrary/**/*.h'

  # Resources
  spec.resources                = ['Sources/MyiOSLibrary/Resources/**/*']
  spec.resource_bundles = {
    'MyiOSLibrary' => [
      'Sources/MyiOSLibrary/Resources/**/*.{png,jpg,jpeg,storyboard,xib,xcassets,strings,plist}'
    ]
  }

  # Subspecs for modular architecture
  spec.subspec 'Core' do |core|
    core.source_files = 'Sources/MyiOSLibrary/Core/**/*.swift'
  end

  spec.subspec 'UI' do |ui|
    ui.source_files = 'Sources/MyiOSLibrary/UI/**/*.swift'
    ui.dependency 'MyiOSLibrary/Core'
    ui.frameworks = 'UIKit'
  end

  spec.subspec 'Networking' do |networking|
    networking.source_files = 'Sources/MyiOSLibrary/Networking/**/*.swift'
    networking.dependency 'MyiOSLibrary/Core'
    networking.dependency 'Alamofire', '~> 5.8'
  end

  # Framework dependencies
  spec.frameworks               = 'Foundation', 'UIKit', 'CoreData'
  spec.weak_frameworks          = 'SwiftUI', 'Combine'

  # External dependencies
  spec.dependency 'Alamofire', '~> 5.8'
  spec.dependency 'Kingfisher', '~> 7.9'

  # Build settings
  spec.requires_arc             = true
  spec.pod_target_xcconfig = {
    'SWIFT_VERSION' => '5.9',
    'IPHONEOS_DEPLOYMENT_TARGET' => '15.0'
  }

  # Test specification
  spec.test_spec 'Tests' do |test_spec|
    test_spec.source_files = 'Tests/**/*.swift'
    test_spec.frameworks = 'XCTest'
    test_spec.dependency 'Quick'
    test_spec.dependency 'Nimble'
  end
end
```

### Podfile for iOS App
```ruby
# Podfile
platform :ios, '15.0'
use_frameworks!
use_modular_headers!

# Define sources
source 'https://github.com/CocoaPods/Specs.git'

# Global configurations
install! 'cocoapods', :deterministic_uuids => false

target 'MyiOSApp' do
  # UI & Animation
  pod 'SnapKit', '~> 5.6'
  pod 'lottie-ios', '~> 4.3'
  
  # Networking
  pod 'Alamofire', '~> 5.8'
  pod 'Moya', '~> 15.0'
  
  # Image Loading
  pod 'Kingfisher', '~> 7.9'
  
  # Data Persistence
  pod 'RealmSwift', '~> 10.44'
  
  # Reactive Programming
  pod 'RxSwift', '~> 6.6'
  pod 'RxCocoa', '~> 6.6'
  
  # Analytics & Crash Reporting
  pod 'Firebase/Analytics'
  pod 'Firebase/Crashlytics'
  
  # Development pods (local)
  pod 'MyiOSLibrary', :path => '../MyiOSLibrary'

  target 'MyiOSAppTests' do
    inherit! :search_paths
    
    pod 'Quick', '~> 7.3'
    pod 'Nimble', '~> 12.3'
    pod 'RxTest', '~> 6.6'
    pod 'RxBlocking', '~> 6.6'
  end

  target 'MyiOSAppUITests' do
    # UI testing pods if needed
  end
end

# Post install configuration
post_install do |installer|
  installer.pods_project.targets.each do |target|
    target.build_configurations.each do |config|
      # Ensure iOS deployment target consistency
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.0'
      
      # Enable bitcode if needed
      config.build_settings['ENABLE_BITCODE'] = 'NO'
      
      # Code signing configuration
      config.build_settings['CODE_SIGNING_REQUIRED'] = 'NO'
      config.build_settings['CODE_SIGNING_ALLOWED'] = 'NO'
      
      # Swift version consistency
      config.build_settings['SWIFT_VERSION'] = '5.9'
      
      # Optimization settings
      if config.name == 'Debug'
        config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-Onone'
        config.build_settings['SWIFT_ACTIVE_COMPILATION_CONDITIONS'] = 'DEBUG'
      else
        config.build_settings['SWIFT_OPTIMIZATION_LEVEL'] = '-O'
        config.build_settings['SWIFT_COMPILATION_MODE'] = 'wholemodule'
      end
      
      # Suppress warnings for specific pods
      if target.name == 'Alamofire'
        config.build_settings['GCC_WARN_INHIBIT_ALL_WARNINGS'] = 'YES'
      end
    end
  end
  
  # Fix for Xcode 14+ build issues
  installer.generated_projects.each do |project|
    project.targets.each do |target|
      target.build_configurations.each do |config|
        config.build_settings['CODE_SIGN_IDENTITY'] = ''
      end
    end
  end
end
```

## Carthage Support

### Cartfile Configuration
```
# Cartfile
github "Alamofire/Alamofire" ~> 5.8
github "onevcat/Kingfisher" ~> 7.9
github "realm/realm-swift" ~> 10.44
github "ReactiveX/RxSwift" ~> 6.6
github "SnapKit/SnapKit" ~> 5.6

# Binary frameworks
binary "https://example.com/MyFramework.json" ~> 1.0
```

### Build Script for Carthage
```bash
#!/bin/bash
# Scripts/build_carthage.sh

set -e

echo "üèóÔ∏è  Building Carthage dependencies..."

# Update dependencies
carthage update --platform iOS --use-xcframeworks

echo "‚úÖ Carthage build completed successfully"

# Verify frameworks
echo "üì¶ Verifying frameworks..."
ls -la Carthage/Build/

# Optional: Create universal framework script
echo "üîß Creating universal frameworks..."
./Scripts/create_universal_frameworks.sh
```

## XCFramework Creation

### Build Script for XCFramework
```bash
#!/bin/bash
# Scripts/build_xcframework.sh

set -e

FRAMEWORK_NAME="MyiOSLibrary"
BUILD_DIR="Build"
XCFRAMEWORK_OUTPUT="$BUILD_DIR/$FRAMEWORK_NAME.xcframework"

echo "üèóÔ∏è  Building XCFramework for $FRAMEWORK_NAME..."

# Clean previous builds
rm -rf "$BUILD_DIR"
mkdir -p "$BUILD_DIR"

# Build for iOS device
echo "üì± Building for iOS device..."
xcodebuild archive \
  -workspace MyiOSLibrary.xcworkspace \
  -scheme $FRAMEWORK_NAME \
  -destination "generic/platform=iOS" \
  -archivePath "$BUILD_DIR/ios.xcarchive" \
  SKIP_INSTALL=NO \
  BUILD_LIBRARY_FOR_DISTRIBUTION=YES

# Build for iOS simulator
echo "üì± Building for iOS simulator..."
xcodebuild archive \
  -workspace MyiOSLibrary.xcworkspace \
  -scheme $FRAMEWORK_NAME \
  -destination "generic/platform=iOS Simulator" \
  -archivePath "$BUILD_DIR/ios-simulator.xcarchive" \
  SKIP_INSTALL=NO \
  BUILD_LIBRARY_FOR_DISTRIBUTION=YES

# Build for macOS (Mac Catalyst)
echo "üíª Building for macOS..."
xcodebuild archive \
  -workspace MyiOSLibrary.xcworkspace \
  -scheme $FRAMEWORK_NAME \
  -destination "generic/platform=macOS,variant=Mac Catalyst" \
  -archivePath "$BUILD_DIR/maccatalyst.xcarchive" \
  SKIP_INSTALL=NO \
  BUILD_LIBRARY_FOR_DISTRIBUTION=YES

# Create XCFramework
echo "üì¶ Creating XCFramework..."
xcodebuild -create-xcframework \
  -framework "$BUILD_DIR/ios.xcarchive/Products/Library/Frameworks/$FRAMEWORK_NAME.framework" \
  -framework "$BUILD_DIR/ios-simulator.xcarchive/Products/Library/Frameworks/$FRAMEWORK_NAME.framework" \
  -framework "$BUILD_DIR/maccatalyst.xcarchive/Products/Library/Frameworks/$FRAMEWORK_NAME.framework" \
  -output "$XCFRAMEWORK_OUTPUT"

echo "‚úÖ XCFramework created at: $XCFRAMEWORK_OUTPUT"

# Verify XCFramework
echo "üîç Verifying XCFramework..."
xcodebuild -checkFirstLaunchArchive -archivePath "$XCFRAMEWORK_OUTPUT"

# Create distribution package
echo "üì¶ Creating distribution package..."
./Scripts/create_distribution_package.sh "$XCFRAMEWORK_OUTPUT"

echo "üéâ Build completed successfully!"
```

### Distribution Package Script
```bash
#!/bin/bash
# Scripts/create_distribution_package.sh

XCFRAMEWORK_PATH=$1
FRAMEWORK_NAME="MyiOSLibrary"
VERSION=$(git describe --tags --abbrev=0)
PACKAGE_NAME="${FRAMEWORK_NAME}-${VERSION}"
DIST_DIR="Distribution"

echo "üì¶ Creating distribution package for $PACKAGE_NAME..."

# Clean and create distribution directory
rm -rf "$DIST_DIR"
mkdir -p "$DIST_DIR/$PACKAGE_NAME"

# Copy XCFramework
cp -R "$XCFRAMEWORK_PATH" "$DIST_DIR/$PACKAGE_NAME/"

# Copy documentation and license
cp README.md "$DIST_DIR/$PACKAGE_NAME/"
cp LICENSE "$DIST_DIR/$PACKAGE_NAME/"
cp CHANGELOG.md "$DIST_DIR/$PACKAGE_NAME/"

# Create Package.swift for binary distribution
cat > "$DIST_DIR/$PACKAGE_NAME/Package.swift" << EOF
// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "$FRAMEWORK_NAME",
    platforms: [
        .iOS(.v15),
        .macOS(.v12)
    ],
    products: [
        .library(
            name: "$FRAMEWORK_NAME",
            targets: ["$FRAMEWORK_NAME"]
        ),
    ],
    targets: [
        .binaryTarget(
            name: "$FRAMEWORK_NAME",
            path: "$FRAMEWORK_NAME.xcframework"
        ),
    ]
)
EOF

# Create ZIP package
cd "$DIST_DIR"
zip -r "${PACKAGE_NAME}.zip" "$PACKAGE_NAME"
cd ..

echo "‚úÖ Distribution package created: $DIST_DIR/${PACKAGE_NAME}.zip"

# Calculate checksums
echo "üîê Calculating checksums..."
shasum -a 256 "$DIST_DIR/${PACKAGE_NAME}.zip" > "$DIST_DIR/${PACKAGE_NAME}.zip.sha256"

echo "üìä Package information:"
echo "  - Name: $PACKAGE_NAME"
echo "  - Version: $VERSION"
echo "  - Size: $(du -h "$DIST_DIR/${PACKAGE_NAME}.zip" | cut -f1)"
echo "  - SHA256: $(cat "$DIST_DIR/${PACKAGE_NAME}.zip.sha256" | cut -d' ' -f1)"
```

## App Store Distribution

### App Store Connect Configuration
```swift
// AppStoreConfig.swift
import Foundation

struct AppStoreConfiguration {
    static let appID = "123456789"
    static let bundleID = "com.company.myapp"
    static let teamID = "ABCDE12345"
    
    #if DEBUG
    static let environment = "sandbox"
    #else
    static let environment = "production"
    #endif
    
    struct InAppPurchases {
        static let premiumFeatures = "com.company.myapp.premium"
        static let removeAds = "com.company.myapp.removeads"
        static let monthlySubscription = "com.company.myapp.monthly"
        static let yearlySubscription = "com.company.myapp.yearly"
    }
    
    struct AppClips {
        static let bundleID = "com.company.myapp.Clip"
        static let experienceURL = "https://example.com/clips"
    }
}
```

### Export Options Configuration
```xml
<!-- ExportOptions.plist -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>method</key>
    <string>app-store</string>
    
    <key>uploadBitcode</key>
    <false/>
    
    <key>uploadSymbols</key>
    <true/>
    
    <key>compileBitcode</key>
    <false/>
    
    <key>teamID</key>
    <string>ABCDE12345</string>
    
    <key>destination</key>
    <string>upload</string>
    
    <key>signingStyle</key>
    <string>automatic</string>
    
    <key>signingCertificate</key>
    <string>iOS Distribution</string>
    
    <key>provisioningProfiles</key>
    <dict>
        <key>com.company.myapp</key>
        <string>MyApp Distribution</string>
        <key>com.company.myapp.Clip</key>
        <string>MyApp Clip Distribution</string>
    </dict>
    
    <key>iCloudContainerEnvironment</key>
    <string>Production</string>
    
    <key>manageAppVersionAndBuildNumber</key>
    <false/>
</dict>
</plist>
```

### Automated Release Script
```bash
#!/bin/bash
# Scripts/release.sh

set -e

VERSION=$1
BUILD_NUMBER=$2

if [ -z "$VERSION" ] || [ -z "$BUILD_NUMBER" ]; then
    echo "Usage: $0 <version> <build_number>"
    echo "Example: $0 1.2.0 42"
    exit 1
fi

echo "üöÄ Starting release process for version $VERSION build $BUILD_NUMBER"

# Update version numbers
echo "üìù Updating version numbers..."
/usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" Info.plist
/usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" Info.plist

# Update App Clip version if exists
if [ -f "AppClip/Info.plist" ]; then
    /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" AppClip/Info.plist
    /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" AppClip/Info.plist
fi

# Run tests
echo "üß™ Running tests..."
xcodebuild test \
    -workspace MyApp.xcworkspace \
    -scheme MyApp \
    -destination 'platform=iOS Simulator,name=iPhone 15' \
    -enableCodeCoverage YES

# Archive for App Store
echo "üì¶ Creating archive..."
xcodebuild archive \
    -workspace MyApp.xcworkspace \
    -scheme MyApp \
    -destination 'generic/platform=iOS' \
    -archivePath "MyApp-$VERSION.xcarchive" \
    -allowProvisioningUpdates

# Export IPA
echo "üì§ Exporting IPA..."
xcodebuild -exportArchive \
    -archivePath "MyApp-$VERSION.xcarchive" \
    -exportPath "Export/" \
    -exportOptionsPlist ExportOptions.plist

# Upload to App Store Connect
echo "‚òÅÔ∏è  Uploading to App Store Connect..."
xcrun altool --upload-app \
    --type ios \
    --file "Export/MyApp.ipa" \
    --username "$APPLE_ID_USERNAME" \
    --password "$APPLE_ID_PASSWORD"

# Create git tag
echo "üè∑Ô∏è  Creating git tag..."
git tag -a "v$VERSION" -m "Release version $VERSION"
git push origin "v$VERSION"

# Update changelog
echo "üìã Updating changelog..."
echo "## Version $VERSION (Build $BUILD_NUMBER)" >> CHANGELOG.md
echo "Released: $(date '+%Y-%m-%d')" >> CHANGELOG.md
echo "" >> CHANGELOG.md

echo "‚úÖ Release process completed successfully!"
echo "üì± App uploaded to App Store Connect"
echo "üè∑Ô∏è  Git tag created: v$VERSION"
```

## Privacy & Compliance

### Privacy Manifest (PrivacyInfo.xcprivacy)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSPrivacyCollectedDataTypes</key>
    <array>
        <dict>
            <key>NSPrivacyCollectedDataType</key>
            <string>NSPrivacyCollectedDataTypeEmailAddress</string>
            <key>NSPrivacyCollectedDataTypeLinked</key>
            <true/>
            <key>NSPrivacyCollectedDataTypeTracking</key>
            <false/>
            <key>NSPrivacyCollectedDataTypePurposes</key>
            <array>
                <string>NSPrivacyCollectedDataTypePurposeAppFunctionality</string>
                <string>NSPrivacyCollectedDataTypePurposeUserAccountManagement</string>
            </array>
        </dict>
    </array>
    
    <key>NSPrivacyAccessedAPITypes</key>
    <array>
        <dict>
            <key>NSPrivacyAccessedAPIType</key>
            <string>NSPrivacyAccessedAPICategoryUserDefaults</string>
            <key>NSPrivacyAccessedAPITypeReasons</key>
            <array>
                <string>CA92.1</string>
            </array>
        </dict>
    </array>
    
    <key>NSPrivacyTrackingDomains</key>
    <array>
        <string>analytics.example.com</string>
    </array>
    
    <key>NSPrivacyTracking</key>
    <false/>
</dict>
</plist>
```

## Best Practices

### Package Management
- Use semantic versioning for all packages
- Pin dependency versions in production
- Regular dependency updates and security audits
- Document breaking changes in CHANGELOG.md
- Provide migration guides for major version updates

### Distribution Strategy
- Use XCFrameworks for cross-platform compatibility
- Implement proper code signing and provisioning
- Automate build and release processes
- Monitor app performance and crash reports
- Implement feature flags for gradual rollouts

### Security Considerations
- Never include sensitive data in packages
- Use proper code obfuscation for proprietary code
- Implement certificate pinning for network security
- Regular security audits of dependencies
- Follow Apple's privacy guidelines and requirements