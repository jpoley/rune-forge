# Python Error Handling Comprehensive Guide\n\n## Exception Hierarchy\n\nPython's exception hierarchy provides a structured approach to error handling:\n\n```\nBaseException\n ├── SystemExit\n ├── KeyboardInterrupt\n ├── GeneratorExit\n └── Exception\n     ├── StopIteration\n     ├── StopAsyncIteration\n     ├── ArithmeticError\n     │   ├── FloatingPointError\n     │   ├── OverflowError\n     │   └── ZeroDivisionError\n     ├── AssertionError\n     ├── AttributeError\n     ├── BufferError\n     ├── EOFError\n     ├── ImportError\n     │   └── ModuleNotFoundError\n     ├── LookupError\n     │   ├── IndexError\n     │   └── KeyError\n     ├── MemoryError\n     ├── NameError\n     │   └── UnboundLocalError\n     ├── OSError\n     │   ├── BlockingIOError\n     │   ├── ChildProcessError\n     │   ├── ConnectionError\n     │   │   ├── BrokenPipeError\n     │   │   ├── ConnectionAbortedError\n     │   │   ├── ConnectionRefusedError\n     │   │   └── ConnectionResetError\n     │   ├── FileExistsError\n     │   ├── FileNotFoundError\n     │   ├── InterruptedError\n     │   ├── IsADirectoryError\n     │   ├── NotADirectoryError\n     │   ├── PermissionError\n     │   ├── ProcessLookupError\n     │   └── TimeoutError\n     ├── ReferenceError\n     ├── RuntimeError\n     │   ├── NotImplementedError\n     │   └── RecursionError\n     ├── SyntaxError\n     │   └── IndentationError\n     │       └── TabError\n     ├── SystemError\n     ├── TypeError\n     ├── ValueError\n     │   └── UnicodeError\n     │       ├── UnicodeDecodeError\n     │       ├── UnicodeEncodeError\n     │       └── UnicodeTranslateError\n     └── Warning\n         ├── DeprecationWarning\n         ├── PendingDeprecationWarning\n         ├── RuntimeWarning\n         ├── SyntaxWarning\n         ├── UserWarning\n         └── FutureWarning\n```\n\n## Basic Exception Handling\n\n### Try-Except Blocks\n\n```python\n# Basic try-except\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\n    result = float('inf')\n\n# Multiple exception types\ntry:\n    value = int(input(\"Enter a number: \"))\n    result = 10 / value\nexcept ValueError:\n    print(\"Invalid number format\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n\n# Multiple exceptions in one clause\ntry:\n    # risky operation\n    pass\nexcept (ValueError, TypeError, KeyError) as e:\n    print(f\"One of several errors occurred: {e}\")\n\n# Catching all exceptions (use sparingly)\ntry:\n    # risky operation\n    pass\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n    # Log the error\n    import logging\n    logging.exception(\"Error details:\")\n```\n\n### Exception Information\n\n```python\nimport sys\nimport traceback\n\ntry:\n    raise ValueError(\"Something went wrong\")\nexcept ValueError as e:\n    # Exception object\n    print(f\"Exception type: {type(e).__name__}\")\n    print(f\"Exception message: {str(e)}\")\n    print(f\"Exception args: {e.args}\")\n    \n    # Traceback information\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n    print(f\"Exception type: {exc_type.__name__}\")\n    print(f\"Exception value: {exc_value}\")\n    \n    # Print full traceback\n    traceback.print_exc()\n    \n    # Get traceback as string\n    tb_str = traceback.format_exc()\n    print(f\"Traceback string:\\n{tb_str}\")\n```\n\n### Finally and Else Clauses\n\n```python\n# Finally clause - always executes\ntry:\n    file = open('data.txt', 'r')\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\n    data = None\nfinally:\n    # Always executes, even if exception occurs\n    if 'file' in locals() and not file.closed:\n        file.close()\n        print(\"File closed\")\n\n# Else clause - executes only if no exception\ntry:\n    result = int(input(\"Enter a number: \"))\nexcept ValueError:\n    print(\"Invalid input\")\nelse:\n    # Only runs if no exception in try block\n    print(f\"You entered: {result}\")\n    squared = result ** 2\n    print(f\"Squared: {squared}\")\nfinally:\n    print(\"Input processing complete\")\n```\n\n## Raising Exceptions\n\n### Basic Exception Raising\n\n```python\n# Raise built-in exceptions\ndef validate_age(age):\n    if not isinstance(age, int):\n        raise TypeError(\"Age must be an integer\")\n    if age < 0:\n        raise ValueError(\"Age cannot be negative\")\n    if age > 150:\n        raise ValueError(\"Age seems unrealistic\")\n    return age\n\n# Re-raising exceptions\ntry:\n    validate_age(-5)\nexcept ValueError:\n    print(\"Validation failed\")\n    raise  # Re-raise the same exception\n\n# Raising with different message\ntry:\n    risky_operation()\nexcept OriginalError as e:\n    raise NewError(\"Context-specific message\") from e\n```\n\n### Exception Chaining\n\n```python\n# Explicit exception chaining\ndef process_data(data):\n    try:\n        return data.upper()\n    except AttributeError as e:\n        raise ProcessingError(\"Failed to process data\") from e\n\n# Suppress exception chaining\ndef clean_process(data):\n    try:\n        return risky_processing(data)\n    except OriginalError:\n        raise NewError(\"Clean error message\") from None\n\n# Chain of exceptions example\nclass DatabaseError(Exception):\n    pass\n\nclass ConnectionError(Exception):\n    pass\n\ndef connect_to_db():\n    try:\n        # Simulate connection failure\n        raise ConnectionError(\"Cannot connect to server\")\n    except ConnectionError as e:\n        raise DatabaseError(\"Database operation failed\") from e\n\ntry:\n    connect_to_db()\nexcept DatabaseError as e:\n    print(f\"Top-level error: {e}\")\n    print(f\"Caused by: {e.__cause__}\")\n    print(f\"Context: {e.__context__}\")\n```\n\n## Custom Exceptions\n\n### Basic Custom Exceptions\n\n```python\n# Simple custom exception\nclass ValidationError(Exception):\n    \"\"\"Raised when data validation fails\"\"\"\n    pass\n\n# Custom exception with additional attributes\nclass ConfigurationError(Exception):\n    \"\"\"Raised when configuration is invalid\"\"\"\n    \n    def __init__(self, message, config_file=None, line_number=None):\n        super().__init__(message)\n        self.config_file = config_file\n        self.line_number = line_number\n    \n    def __str__(self):\n        base_message = super().__str__()\n        if self.config_file:\n            return f\"{base_message} in {self.config_file}\"\n        if self.line_number:\n            return f\"{base_message} at line {self.line_number}\"\n        return base_message\n\n# Exception with custom behavior\nclass RetryableError(Exception):\n    \"\"\"Exception that includes retry logic\"\"\"\n    \n    def __init__(self, message, max_retries=3, retry_delay=1.0):\n        super().__init__(message)\n        self.max_retries = max_retries\n        self.retry_delay = retry_delay\n        self.attempts = 0\n    \n    def should_retry(self):\n        return self.attempts < self.max_retries\n    \n    def increment_attempt(self):\n        self.attempts += 1\n```\n\n### Exception Hierarchies\n\n```python\n# Create exception hierarchy for a domain\nclass APIError(Exception):\n    \"\"\"Base exception for API-related errors\"\"\"\n    pass\n\nclass AuthenticationError(APIError):\n    \"\"\"Raised when authentication fails\"\"\"\n    pass\n\nclass AuthorizationError(APIError):\n    \"\"\"Raised when user lacks permission\"\"\"\n    pass\n\nclass RateLimitError(APIError):\n    \"\"\"Raised when API rate limit is exceeded\"\"\"\n    \n    def __init__(self, message, retry_after=None):\n        super().__init__(message)\n        self.retry_after = retry_after\n\nclass ServerError(APIError):\n    \"\"\"Raised for server-side errors\"\"\"\n    pass\n\n# Usage with hierarchy\ndef handle_api_call():\n    try:\n        make_api_request()\n    except AuthenticationError:\n        print(\"Please log in again\")\n    except AuthorizationError:\n        print(\"Access denied\")\n    except RateLimitError as e:\n        if e.retry_after:\n            print(f\"Rate limited. Retry after {e.retry_after} seconds\")\n        else:\n            print(\"Rate limited\")\n    except ServerError:\n        print(\"Server error, try again later\")\n    except APIError:\n        print(\"API error occurred\")\n```\n\n## Advanced Error Handling Patterns\n\n### Context Managers for Error Handling\n\n```python\nfrom contextlib import contextmanager\nimport logging\n\n@contextmanager\ndef error_handler(operation_name, reraise=True):\n    \"\"\"Context manager for consistent error handling\"\"\"\n    try:\n        yield\n    except Exception as e:\n        logging.error(f\"Error in {operation_name}: {e}\")\n        if reraise:\n            raise\n\n# Usage\nwith error_handler(\"file processing\"):\n    process_file(\"data.txt\")\n\n# Suppress exceptions\nwith error_handler(\"optional operation\", reraise=False):\n    optional_cleanup()\n```\n\n### Decorator for Error Handling\n\n```python\nfrom functools import wraps\nimport logging\n\ndef handle_errors(default_return=None, log_errors=True, reraise=False):\n    \"\"\"Decorator for consistent error handling\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except Exception as e:\n                if log_errors:\n                    logging.error(f\"Error in {func.__name__}: {e}\")\n                if reraise:\n                    raise\n                return default_return\n        return wrapper\n    return decorator\n\n# Usage\n@handle_errors(default_return=[], log_errors=True)\ndef risky_function():\n    # might raise an exception\n    return process_data()\n\n@handle_errors(reraise=True)\ndef critical_function():\n    # errors must be handled by caller\n    return important_operation()\n```\n\n### Retry Logic\n\n```python\nimport time\nimport random\nfrom functools import wraps\n\ndef retry(max_attempts=3, delay=1.0, backoff=2.0, exceptions=(Exception,)):\n    \"\"\"Decorator to retry function calls\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            attempt = 0\n            current_delay = delay\n            \n            while attempt < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    attempt += 1\n                    if attempt >= max_attempts:\n                        raise\n                    \n                    print(f\"Attempt {attempt} failed: {e}\")\n                    print(f\"Retrying in {current_delay} seconds...\")\n                    time.sleep(current_delay)\n                    current_delay *= backoff\n            \n        return wrapper\n    return decorator\n\n# Usage\n@retry(max_attempts=3, delay=1.0, exceptions=(ConnectionError, TimeoutError))\ndef unreliable_network_call():\n    # Simulate unreliable network operation\n    if random.random() < 0.7:  # 70% failure rate\n        raise ConnectionError(\"Network unreachable\")\n    return \"Success!\"\n```\n\n### Circuit Breaker Pattern\n\n```python\nimport time\nfrom enum import Enum\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"\n    OPEN = \"open\"\n    HALF_OPEN = \"half_open\"\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for handling cascading failures\"\"\"\n    \n    def __init__(self, failure_threshold=5, timeout=60, recovery_threshold=2):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.recovery_threshold = recovery_threshold\n        \n        self.failure_count = 0\n        self.success_count = 0\n        self.last_failure_time = None\n        self.state = CircuitState.CLOSED\n    \n    def call(self, func, *args, **kwargs):\n        if self.state == CircuitState.OPEN:\n            if time.time() - self.last_failure_time > self.timeout:\n                self.state = CircuitState.HALF_OPEN\n                self.success_count = 0\n            else:\n                raise CircuitBreakerOpen(\"Circuit breaker is open\")\n        \n        try:\n            result = func(*args, **kwargs)\n            self._record_success()\n            return result\n        except Exception as e:\n            self._record_failure()\n            raise\n    \n    def _record_success(self):\n        self.failure_count = 0\n        if self.state == CircuitState.HALF_OPEN:\n            self.success_count += 1\n            if self.success_count >= self.recovery_threshold:\n                self.state = CircuitState.CLOSED\n    \n    def _record_failure(self):\n        self.failure_count += 1\n        self.last_failure_time = time.time()\n        \n        if (self.failure_count >= self.failure_threshold or \n            self.state == CircuitState.HALF_OPEN):\n            self.state = CircuitState.OPEN\n\nclass CircuitBreakerOpen(Exception):\n    \"\"\"Raised when circuit breaker is open\"\"\"\n    pass\n\n# Usage\nbreaker = CircuitBreaker(failure_threshold=3, timeout=30)\n\ndef protected_call():\n    return breaker.call(unreliable_service_call)\n```\n\n## Error Handling Best Practices\n\n### Specific Exception Handling\n\n```python\n# Good: Specific exception handling\ntry:\n    user_id = int(request.args.get('user_id'))\nexcept (ValueError, TypeError):\n    return {\"error\": \"Invalid user ID format\"}, 400\n\ntry:\n    user = database.get_user(user_id)\nexcept UserNotFoundError:\n    return {\"error\": \"User not found\"}, 404\nexcept DatabaseConnectionError:\n    return {\"error\": \"Service temporarily unavailable\"}, 503\n\n# Bad: Overly broad exception handling\ntry:\n    user_id = int(request.args.get('user_id'))\n    user = database.get_user(user_id)\nexcept Exception:\n    return {\"error\": \"Something went wrong\"}, 500\n```\n\n### Error Logging and Monitoring\n\n```python\nimport logging\nimport sys\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('app.log'),\n        logging.StreamHandler(sys.stdout)\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\ndef process_user_data(user_data):\n    try:\n        # Process data\n        validate_user_data(user_data)\n        result = transform_data(user_data)\n        save_to_database(result)\n        logger.info(f\"Successfully processed user {user_data.get('id')}\")\n        return result\n        \n    except ValidationError as e:\n        logger.warning(f\"Validation failed for user {user_data.get('id')}: {e}\")\n        raise\n        \n    except DatabaseError as e:\n        logger.error(f\"Database error for user {user_data.get('id')}: {e}\")\n        # Could implement retry logic here\n        raise\n        \n    except Exception as e:\n        logger.exception(f\"Unexpected error processing user {user_data.get('id')}\")\n        # Don't re-raise unexpected exceptions in production\n        # Instead, handle gracefully or convert to known exception type\n        raise ProcessingError(\"Failed to process user data\") from e\n```\n\n### Validation and Error Messages\n\n```python\nclass ValidationError(Exception):\n    \"\"\"Exception for validation errors with detailed messages\"\"\"\n    \n    def __init__(self, message, field=None, value=None, code=None):\n        super().__init__(message)\n        self.field = field\n        self.value = value\n        self.code = code\n    \n    def to_dict(self):\n        return {\n            \"message\": str(self),\n            \"field\": self.field,\n            \"value\": self.value,\n            \"code\": self.code\n        }\n\ndef validate_email(email):\n    \"\"\"Validate email with detailed error information\"\"\"\n    if not email:\n        raise ValidationError(\n            \"Email is required\",\n            field=\"email\",\n            code=\"REQUIRED\"\n        )\n    \n    if not isinstance(email, str):\n        raise ValidationError(\n            \"Email must be a string\",\n            field=\"email\",\n            value=type(email).__name__,\n            code=\"INVALID_TYPE\"\n        )\n    \n    if '@' not in email:\n        raise ValidationError(\n            \"Email must contain @ symbol\",\n            field=\"email\",\n            value=email,\n            code=\"INVALID_FORMAT\"\n        )\n    \n    if len(email) > 255:\n        raise ValidationError(\n            \"Email is too long (maximum 255 characters)\",\n            field=\"email\",\n            value=len(email),\n            code=\"TOO_LONG\"\n        )\n\n# Usage\ntry:\n    validate_email(\"invalid-email\")\nexcept ValidationError as e:\n    error_info = e.to_dict()\n    print(f\"Validation failed: {error_info}\")\n```\n\n### Resource Management\n\n```python\n# Context manager for database connections\nfrom contextlib import contextmanager\n\n@contextmanager\ndef database_transaction():\n    \"\"\"Context manager for database transactions\"\"\"\n    conn = None\n    try:\n        conn = get_database_connection()\n        conn.begin()\n        yield conn\n        conn.commit()\n    except Exception as e:\n        if conn:\n            conn.rollback()\n        raise\n    finally:\n        if conn:\n            conn.close()\n\n# Usage\ntry:\n    with database_transaction() as conn:\n        create_user(conn, user_data)\n        send_welcome_email(user_data['email'])\nexcept DatabaseError as e:\n    logger.error(f\"Database error: {e}\")\n    return {\"error\": \"Failed to create user\"}, 500\nexcept EmailError as e:\n    logger.warning(f\"Email error: {e}\")\n    # User was created but email failed - this might be acceptable\n    return {\"warning\": \"User created but welcome email failed\"}, 201\n```\n\n## Error Handling in Different Contexts\n\n### Web Applications\n\n```python\nfrom flask import Flask, request, jsonify\nimport logging\n\napp = Flask(__name__)\n\nclass APIError(Exception):\n    \"\"\"Base API error with HTTP status codes\"\"\"\n    \n    def __init__(self, message, status_code=500, payload=None):\n        super().__init__(message)\n        self.message = message\n        self.status_code = status_code\n        self.payload = payload\n    \n    def to_dict(self):\n        result = dict(self.payload or ())\n        result['message'] = self.message\n        return result\n\n@app.errorhandler(APIError)\ndef handle_api_error(error):\n    response = jsonify(error.to_dict())\n    response.status_code = error.status_code\n    return response\n\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({\"error\": \"Resource not found\"}), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    logging.exception(\"Internal server error\")\n    return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route('/users/<int:user_id>')\ndef get_user(user_id):\n    try:\n        user = database.get_user(user_id)\n        if not user:\n            raise APIError(\"User not found\", status_code=404)\n        return jsonify(user.to_dict())\n    \n    except DatabaseConnectionError:\n        raise APIError(\"Service temporarily unavailable\", status_code=503)\n```\n\n### Async Error Handling\n\n```python\nimport asyncio\nimport aiohttp\nimport logging\n\nasync def fetch_with_retry(session, url, max_retries=3):\n    \"\"\"Fetch URL with retry logic for async operations\"\"\"\n    for attempt in range(max_retries):\n        try:\n            async with session.get(url) as response:\n                if response.status == 200:\n                    return await response.text()\n                elif response.status >= 500:\n                    # Server error - retry\n                    if attempt < max_retries - 1:\n                        await asyncio.sleep(2 ** attempt)  # Exponential backoff\n                        continue\n                    else:\n                        raise aiohttp.ClientResponseError(\n                            request_info=response.request_info,\n                            history=response.history,\n                            status=response.status\n                        )\n                else:\n                    # Client error - don't retry\n                    raise aiohttp.ClientResponseError(\n                        request_info=response.request_info,\n                        history=response.history,\n                        status=response.status\n                    )\n                    \n        except aiohttp.ClientConnectionError as e:\n            if attempt < max_retries - 1:\n                logging.warning(f\"Connection error on attempt {attempt + 1}: {e}\")\n                await asyncio.sleep(2 ** attempt)\n                continue\n            else:\n                raise\n        \n        except asyncio.TimeoutError:\n            if attempt < max_retries - 1:\n                logging.warning(f\"Timeout on attempt {attempt + 1}\")\n                await asyncio.sleep(2 ** attempt)\n                continue\n            else:\n                raise\n\nasync def process_urls(urls):\n    \"\"\"Process multiple URLs with proper error handling\"\"\"\n    async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:\n        tasks = []\n        \n        for url in urls:\n            task = asyncio.create_task(fetch_with_retry(session, url))\n            tasks.append((url, task))\n        \n        results = []\n        for url, task in tasks:\n            try:\n                content = await task\n                results.append({\"url\": url, \"status\": \"success\", \"content\": content})\n            except Exception as e:\n                logging.error(f\"Failed to fetch {url}: {e}\")\n                results.append({\"url\": url, \"status\": \"error\", \"error\": str(e)})\n        \n        return results\n```\n\n### Testing Error Conditions\n\n```python\nimport pytest\nfrom unittest.mock import patch, MagicMock\n\ndef test_user_validation_errors():\n    \"\"\"Test various validation error conditions\"\"\"\n    \n    # Test required field\n    with pytest.raises(ValidationError) as exc_info:\n        validate_user_data({})\n    assert \"name is required\" in str(exc_info.value)\n    \n    # Test invalid email\n    with pytest.raises(ValidationError) as exc_info:\n        validate_user_data({\"name\": \"John\", \"email\": \"invalid\"})\n    assert exc_info.value.field == \"email\"\n    assert exc_info.value.code == \"INVALID_FORMAT\"\n\ndef test_database_error_handling():\n    \"\"\"Test database error handling\"\"\"\n    \n    with patch('myapp.database.get_user') as mock_get_user:\n        # Test connection error\n        mock_get_user.side_effect = DatabaseConnectionError(\"Connection lost\")\n        \n        with pytest.raises(ServiceUnavailableError):\n            user_service.get_user(123)\n        \n        # Test user not found\n        mock_get_user.return_value = None\n        \n        with pytest.raises(UserNotFoundError):\n            user_service.get_user(123)\n\ndef test_retry_mechanism():\n    \"\"\"Test retry functionality\"\"\"\n    \n    with patch('myapp.external_api.call_service') as mock_call:\n        # First two calls fail, third succeeds\n        mock_call.side_effect = [\n            ConnectionError(\"Network error\"),\n            TimeoutError(\"Request timeout\"),\n            {\"result\": \"success\"}\n        ]\n        \n        result = retry_service_call()\n        assert result == {\"result\": \"success\"}\n        assert mock_call.call_count == 3\n```\n\nThis comprehensive guide covers Python's error handling mechanisms from basic try-except blocks to advanced patterns like circuit breakers and async error handling, providing both theoretical understanding and practical implementation examples.