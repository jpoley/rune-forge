# Node.js/TypeScript CI/CD Pipeline
# This template implements outer-loop principles:
# - Build once in CI, promote everywhere
# - SBOM generation and attestation
# - Security scanning (SAST, SCA)
# - Immutable artifacts with content-addressable IDs
# - Environment-agnostic builds

name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# OIDC permissions for attestation and deployment
permissions:
  contents: read
  id-token: write
  attestations: write
  packages: write
  pull-requests: write
  security-events: write

env:
  NODE_VERSION: '{{NODE_VERSION}}'  # e.g., "20"
  PACKAGE_MANAGER: '{{PACKAGE_MANAGER}}'  # npm, yarn, or pnpm

jobs:
  # ==========================================================================
  # BUILD: Build once, never rebuild
  # ==========================================================================
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    outputs:
      artifact-digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for versioning

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: ${{ env.PACKAGE_MANAGER }}

      - name: Install dependencies
        run: |
          if [ "${{ env.PACKAGE_MANAGER }}" = "npm" ]; then
            npm ci
          elif [ "${{ env.PACKAGE_MANAGER }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ env.PACKAGE_MANAGER }}" = "pnpm" ]; then
            pnpm install --frozen-lockfile
          fi

      - name: Run linter
        run: {{LINT_COMMAND}}  # e.g., npm run lint

      - name: Run type check
        run: {{TYPECHECK_COMMAND}}  # e.g., npm run typecheck

      - name: Run tests
        run: {{TEST_COMMAND}}  # e.g., npm test

      - name: Calculate version
        id: version
        run: |
          # Use semantic versioning based on git tags
          VERSION=$(git describe --tags --always --dirty)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Build application
        id: build
        env:
          # NO environment-specific config here!
          # All config comes from runtime environment variables
          NODE_ENV: production
        run: |
          {{BUILD_COMMAND}}  # e.g., npm run build
          # Calculate digest of build output
          DIGEST=$(find dist -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          echo "digest=sha256:$DIGEST" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ github.sha }}
          path: dist/
          retention-days: 30

  # ==========================================================================
  # SECURITY: SAST, SCA, Dependency Scanning
  # ==========================================================================
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: |
          if [ "${{ env.PACKAGE_MANAGER }}" = "npm" ]; then
            npm ci
          elif [ "${{ env.PACKAGE_MANAGER }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ env.PACKAGE_MANAGER }}" = "pnpm" ]; then
            pnpm install --frozen-lockfile
          fi

      - name: Run npm audit
        run: |
          if [ "${{ env.PACKAGE_MANAGER }}" = "npm" ]; then
            npm audit --json > npm-audit.json || true
          elif [ "${{ env.PACKAGE_MANAGER }}" = "yarn" ]; then
            yarn audit --json > yarn-audit.json || true
          elif [ "${{ env.PACKAGE_MANAGER }}" = "pnpm" ]; then
            pnpm audit --json > pnpm-audit.json || true
          fi

      - name: Run Snyk security scan
        continue-on-error: true
        run: |
          npx snyk test --json > snyk-report.json || true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        with:
          name: security-reports-${{ github.sha }}
          path: |
            *-audit.json
            snyk-report.json

  # ==========================================================================
  # SBOM: Software Bill of Materials
  # ==========================================================================
  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install CycloneDX
        run: npm install -g @cyclonedx/cyclonedx-npm

      - name: Generate SBOM
        run: |
          cyclonedx-npm --output-file sbom.json
          cyclonedx-npm --output-format XML --output-file sbom.xml

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ github.sha }}
          path: |
            sbom.json
            sbom.xml

  # ==========================================================================
  # CONTAINER: Build container image (if applicable)
  # ==========================================================================
  container:
    name: Build Container Image
    runs-on: ubuntu-latest
    needs: [build, security-scan, sbom]
    if: hashFiles('Dockerfile') != ''
    outputs:
      image-digest: ${{ steps.build-image.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ github.sha }}
          path: dist/

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push image
        id: build-image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true  # SLSA provenance
          sbom: true        # Attach SBOM

      - name: Download SBOM
        uses: actions/download-artifact@v4
        with:
          name: sbom-${{ github.sha }}

      - name: Attest image SBOM
        if: github.event_name != 'pull_request'
        uses: actions/attest-sbom@v1
        with:
          subject-name: ghcr.io/${{ github.repository }}
          subject-digest: ${{ steps.build-image.outputs.digest }}
          sbom-path: sbom.json

  # ==========================================================================
  # ATTESTATION: Sign build artifacts (SLSA provenance)
  # ==========================================================================
  attest:
    name: Attest Build Provenance
    runs-on: ubuntu-latest
    needs: [build, sbom]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ github.sha }}
          path: dist/

      - name: Download SBOM
        uses: actions/download-artifact@v4
        with:
          name: sbom-${{ github.sha }}

      - name: Attest build provenance
        uses: actions/attest-build-provenance@v1
        with:
          subject-path: 'dist/**/*'

      - name: Attest SBOM
        uses: actions/attest-sbom@v1
        with:
          subject-path: 'dist/**/*'
          sbom-path: sbom.json

  # ==========================================================================
  # DEPLOY: Promote (don't rebuild) to environments
  # ==========================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, security-scan, sbom, attest]
    if: github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    environment:
      name: staging
      url: https://staging.{{PROJECT_NAME}}.com
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ github.sha }}
          path: dist/

      - name: Verify artifact digest
        run: |
          DIGEST=$(find dist -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          echo "Artifact digest: sha256:$DIGEST"
          echo "Expected: ${{ needs.build.outputs.artifact-digest }}"
          if [ "sha256:$DIGEST" != "${{ needs.build.outputs.artifact-digest }}" ]; then
            echo "ERROR: Artifact digest mismatch!"
            exit 1
          fi

      - name: Deploy to staging
        run: |
          # Deploy the EXACT SAME artifact built in CI
          # NO rebuilding, NO recompilation
          # Configuration comes from environment variables
          echo "Deploying to staging..."
          # {{DEPLOY_COMMAND}}

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, security-scan, sbom, attest, deploy-staging]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://{{PROJECT_NAME}}.com
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ github.sha }}
          path: dist/

      - name: Verify artifact digest
        run: |
          DIGEST=$(find dist -type f -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          echo "Artifact digest: sha256:$DIGEST"
          echo "Expected: ${{ needs.build.outputs.artifact-digest }}"
          if [ "sha256:$DIGEST" != "${{ needs.build.outputs.artifact-digest }}" ]; then
            echo "ERROR: Artifact digest mismatch!"
            exit 1
          fi

      - name: Deploy to production
        run: |
          # Deploy the EXACT SAME artifact built in CI
          # This is the SAME artifact that was tested in staging
          # NO rebuilding, NO recompilation
          echo "Deploying to production..."
          # {{DEPLOY_COMMAND}}

      - name: Post-deployment verification
        run: |
          # Verify deployment health
          # curl -f https://{{PROJECT_NAME}}.com/health || exit 1
          echo "Deployment verified"
